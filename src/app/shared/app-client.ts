//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch, catchError } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf, of } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';
import { PagingRequest } from './models/base.model';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AdminClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    getThongTinDonViByMST(mst: string | null | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/getinfobytaxcode?";
        if (mst !== undefined && mst !== null)
            url_ += "mst=" + encodeURIComponent("" + mst) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetThongTinDonViByMST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetThongTinDonViByMST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetThongTinDonViByMST(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    khoiTaoDonVi(mst: string | null | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/khoitaonhanh?";
        if (mst !== undefined && mst !== null)
            url_ += "mst=" + encodeURIComponent("" + mst) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processKhoiTaoDonVi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processKhoiTaoDonVi(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processKhoiTaoDonVi(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    changePassword(model: ResetPasswordVm): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/changepassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    getThongKeDonVi(pageIndex: number | null | undefined, pageSize: number | null | undefined, searchText: string | null | undefined, searchDate: string | null | undefined, tenantGroupId: number | null | undefined, status: boolean | null | undefined, tenantId: number | null | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/getthongkedv?";
        if (pageIndex !== undefined && pageIndex !== null)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (searchDate !== undefined && searchDate !== null)
            url_ += "searchDate=" + encodeURIComponent("" + searchDate) + "&";
        if (tenantGroupId !== undefined && tenantGroupId !== null)
            url_ += "TenantGroupId=" + encodeURIComponent("" + tenantGroupId) + "&";
        if (status !== undefined && status !== null)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetThongKeDonVi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetThongKeDonVi(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetThongKeDonVi(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    getThongKeTongHop(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/gethongketonghop";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetThongKeTongHop(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetThongKeTongHop(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetThongKeTongHop(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    getDonViLoiHD(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/getdvloihd";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDonViLoiHD(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDonViLoiHD(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetDonViLoiHD(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    xuatHoaDonThieu(tenantId: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/xuathdthieu";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tenantId);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXuatHoaDonThieu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXuatHoaDonThieu(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processXuatHoaDonThieu(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    dongBoHangLoat(tenantId: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/dongbohd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tenantId);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDongBoHangLoat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDongBoHangLoat(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processDongBoHangLoat(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    getTenantById(tenantId: number | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/getdstenantbyid?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetTenantById(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    getDanhSachTenant(pageIndex: number | null | undefined, pageSize: number | null | undefined, searchText: string | null | undefined, searchDate: string | null | undefined, tenantGroupId: number | null | undefined, status: boolean | null | undefined, tenantId: number | null | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/getdstenant?";
        if (pageIndex !== undefined && pageIndex !== null)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (searchDate !== undefined && searchDate !== null)
            url_ += "searchDate=" + encodeURIComponent("" + searchDate) + "&";
        if (tenantGroupId !== undefined && tenantGroupId !== null)
            url_ += "TenantGroupId=" + encodeURIComponent("" + tenantGroupId) + "&";
        if (status !== undefined && status !== null)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDanhSachTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDanhSachTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetDanhSachTenant(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    createTenant(heThong: KhoiTaoHeThongDto): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/createtenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(heThong);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processCreateTenant(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    editTenant(tenant: Tenant): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/edittenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tenant);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processEditTenant(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    deleteTenant(request: DeleteModelRequest): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/deletetenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processDeleteTenant(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    resetTenant(tenant: Tenant): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/resettenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tenant);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processResetTenant(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    getTenantByGroupId(tenantGroupId: number | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/gettenantbygroupid?";
        if (tenantGroupId === null)
            throw new Error("The parameter 'tenantGroupId' cannot be null.");
        else if (tenantGroupId !== undefined)
            url_ += "tenantGroupId=" + encodeURIComponent("" + tenantGroupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantByGroupId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantByGroupId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetTenantByGroupId(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    getDanhSachLoaiVe(tenantId: number | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/getdsloaive?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDanhSachLoaiVe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDanhSachLoaiVe(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetDanhSachLoaiVe(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    createLoaiVe(loaiVe: LoaiVe): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/createloaive";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loaiVe);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateLoaiVe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateLoaiVe(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processCreateLoaiVe(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    editLoaiVe(loaiVe: LoaiVe): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/editloaive";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loaiVe);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditLoaiVe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditLoaiVe(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processEditLoaiVe(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    deleteLoaiVe(request: DeleteModelRequest): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/deleteloaive";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLoaiVe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLoaiVe(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processDeleteLoaiVe(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    getDanhSachCauHinhHd(tenantId: number | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/getdscauhinhhd?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDanhSachCauHinhHd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDanhSachCauHinhHd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetDanhSachCauHinhHd(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    getCauHinhHoaDon(tenantId: number | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/getinvoicebytenantid?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCauHinhHoaDon(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCauHinhHoaDon(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetCauHinhHoaDon(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    createCauHinhHd(cauHinhHd: CauHinhHoaDon): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/createcauhinhhd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(cauHinhHd);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCauHinhHd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCauHinhHd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processCreateCauHinhHd(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    editCauHinhHd(cauHinhHd: CauHinhHoaDon): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/editcauhinhhd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(cauHinhHd);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditCauHinhHd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditCauHinhHd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processEditCauHinhHd(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    deleteCauHinhHd(cauHinhHdId: number | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/deletecauhinhhd?";
        if (cauHinhHdId === null)
            throw new Error("The parameter 'cauHinhHdId' cannot be null.");
        else if (cauHinhHdId !== undefined)
            url_ += "cauHinhHdId=" + encodeURIComponent("" + cauHinhHdId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCauHinhHd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCauHinhHd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processDeleteCauHinhHd(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    getDanhSachNhomDichVu(tenantId: number | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/getdsnhomdv?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDanhSachNhomDichVu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDanhSachNhomDichVu(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetDanhSachNhomDichVu(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    createNhomDichVu(nhomDichVu: NhomDichVu): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/createnhomdv";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(nhomDichVu);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateNhomDichVu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateNhomDichVu(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processCreateNhomDichVu(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    editNhomDichVu(nhomDichVu: NhomDichVu): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/editnhomdv";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(nhomDichVu);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditNhomDichVu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditNhomDichVu(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processEditNhomDichVu(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    deleteNhomDichVu(request: DeleteModelRequest): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/deletenhomdv";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNhomDichVu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNhomDichVu(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processDeleteNhomDichVu(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    getDanhSachUsers(tenantId: number | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/getdsusers?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDanhSachUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDanhSachUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetDanhSachUsers(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    createUser(model: NhanVienDto): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/createuser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processCreateUser(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    editUser(nhanVien: NhanVienDto): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/edituser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(nhanVien);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processEditUser(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    deleteUser(request: DeleteModelRequest): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/deleteuser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    getTenantGroups(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/getdstenantgroup";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantGroups(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetTenantGroups(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    getTenantGroupById(tenantGroupId: number | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/gettenantgroupbyid?";
        if (tenantGroupId === null)
            throw new Error("The parameter 'tenantGroupId' cannot be null.");
        else if (tenantGroupId !== undefined)
            url_ += "tenantGroupId=" + encodeURIComponent("" + tenantGroupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantGroupById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantGroupById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetTenantGroupById(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    createTenantGroup(tenantGroup: TenantGroup): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/createtenantgroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tenantGroup);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTenantGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTenantGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processCreateTenantGroup(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    editTenantGroup(tenantGroup: TenantGroup): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/edittenantgroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tenantGroup);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditTenantGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditTenantGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processEditTenantGroup(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    deleteTenantGroup(request: DeleteModelRequest): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/deletetenantgroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTenantGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTenantGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processDeleteTenantGroup(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    addOrEditTenantGroupItem(request: ChangeStateTenantGroupRequest): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/changestatetenantgroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrEditTenantGroupItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrEditTenantGroupItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processAddOrEditTenantGroupItem(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    getDanhSachManagers(tenantGroupId: number | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/getdsmanagers?";
        if (tenantGroupId === null)
            throw new Error("The parameter 'tenantGroupId' cannot be null.");
        else if (tenantGroupId !== undefined)
            url_ += "tenantGroupId=" + encodeURIComponent("" + tenantGroupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDanhSachManagers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDanhSachManagers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetDanhSachManagers(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    createManager(model: NhanVienDto): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/createmanager";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManager(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManager(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processCreateManager(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    deleteManager(request: DeleteModelRequest): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/deletemanager";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteManager(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteManager(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processDeleteManager(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    getDanhSachPortals(tenantGroupId: number | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/getdsportals?";
        if (tenantGroupId === null)
            throw new Error("The parameter 'tenantGroupId' cannot be null.");
        else if (tenantGroupId !== undefined)
            url_ += "tenantGroupId=" + encodeURIComponent("" + tenantGroupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDanhSachPortals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDanhSachPortals(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetDanhSachPortals(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    createPortal(model: NhanVienDto): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/createportal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePortal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePortal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processCreatePortal(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    deletePortal(userId: string | null | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/deleteportal?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePortal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePortal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processDeletePortal(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    getPortalGroups(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/getdsportalgroup";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPortalGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPortalGroups(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetPortalGroups(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    createPortalGroup(portalGroup: PortalGroup): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/createportalgroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(portalGroup);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePortalGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePortalGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processCreatePortalGroup(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    editPortalGroup(portalGroup: PortalGroup): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/editportalgroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(portalGroup);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditPortalGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditPortalGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processEditPortalGroup(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    deletePortalGroup(portalGroupId: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/deleteportalgroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(portalGroupId);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePortalGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePortalGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processDeletePortalGroup(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    addOrEditPortalGroupItem(request: ChangeStatePortalGroupRequest): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/admin/changestateportalgroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrEditPortalGroupItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrEditPortalGroupItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processAddOrEditPortalGroupItem(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }
}

@Injectable()
export class PortalApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    getThongKeDonVi(ngay: Date | null | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/portal/getthongkedv?";
        if (ngay !== undefined && ngay !== null)
            url_ += "ngay=" + encodeURIComponent(ngay ? "" + ngay.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetThongKeDonVi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetThongKeDonVi(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetThongKeDonVi(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    changePassword(model: ResetPasswordVm): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/portal/changepassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    xuatHoaDonThieu(tenantId: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/portal/xuathdthieu";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tenantId);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXuatHoaDonThieu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXuatHoaDonThieu(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processXuatHoaDonThieu(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    baoCaoTongHop(request: PortalBaoCaoRequest): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/portal/baocaotonghop";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBaoCaoTongHop(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBaoCaoTongHop(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processBaoCaoTongHop(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    excelBaoCaoTongHop(request: PortalBaoCaoRequest): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/portal/excelbaocaotonghop";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExcelBaoCaoTongHop(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExcelBaoCaoTongHop(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processExcelBaoCaoTongHop(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }
}

@Injectable()
export class PrivateApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    suDungVe(veId: string | null | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/PrivateApi/sudungve?";
        if (veId !== undefined && veId !== null)
            url_ += "veId=" + encodeURIComponent("" + veId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSuDungVe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSuDungVe(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processSuDungVe(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    getThongTinVe(veId: string | null | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/PrivateApi/getthongtinve?";
        if (veId !== undefined && veId !== null)
            url_ += "veId=" + encodeURIComponent("" + veId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetThongTinVe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetThongTinVe(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetThongTinVe(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    getDanhSachLoaiVe(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/PrivateApi/getdanhsachloaive";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDanhSachLoaiVe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDanhSachLoaiVe(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetDanhSachLoaiVe(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    getDSNhomDichVu(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/PrivateApi/nhomdichvus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDSNhomDichVu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDSNhomDichVu(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetDSNhomDichVu(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    taoVe(loaiVeId: number | undefined, base64: string | null | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/PrivateApi/taove?";
        if (loaiVeId === null)
            throw new Error("The parameter 'loaiVeId' cannot be null.");
        else if (loaiVeId !== undefined)
            url_ += "loaiVeId=" + encodeURIComponent("" + loaiVeId) + "&";
        if (base64 !== undefined && base64 !== null)
            url_ += "base64=" + encodeURIComponent("" + base64) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTaoVe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTaoVe(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processTaoVe(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    createTicket(request: TaoVeRequest): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/PrivateApi/taove2";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTicket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTicket(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processCreateTicket(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    getListVeGN(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/PrivateApi/getlistvegn";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListVeGN(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListVeGN(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetListVeGN(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    inLaiVe(veId: string | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/PrivateApi/inlaive?";
        if (veId === null)
            throw new Error("The parameter 'veId' cannot be null.");
        else if (veId !== undefined)
            url_ += "veId=" + encodeURIComponent("" + veId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInLaiVe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInLaiVe(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processInLaiVe(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    thongKeVeNgay(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/PrivateApi/thongkeve";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processThongKeVeNgay(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processThongKeVeNgay(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processThongKeVeNgay(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }
}

@Injectable()
export class PublicApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    authenticate(username: string | null | undefined, password: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/PublicApi/authenticate?";
        if (username !== undefined && username !== null)
            url_ += "Username=" + encodeURIComponent("" + username) + "&";
        if (password !== undefined && password !== null)
            url_ += "Password=" + encodeURIComponent("" + password) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    adminLogin(model: AuthenticateRequest): Observable<string> {
        let url_ = this.baseUrl + "/api/PublicApi/adminlogin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processAdminLogin(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    portalLogin(model: AuthenticateRequest): Observable<string> {
        let url_ = this.baseUrl + "/api/PublicApi/portallogin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPortalLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPortalLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPortalLogin(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class MobileTicketClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    createTicketNormal(request: CreateTicketMobileRequest): Observable<ApiResult> {
        let url_ = this.baseUrl + "/api/MobileTicket/createnormal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTicketNormal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTicketNormal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResult>;
        }));
    }

    protected processCreateTicketNormal(response: HttpResponseBase): Observable<ApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResult>(null as any);
    }

    getDataOfflineTicket(): Observable<ApiResult> {
        let url_ = this.baseUrl + "/api/MobileTicket/GetDataOffline";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataOfflineTicket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataOfflineTicket(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResult>;
        }));
    }

    protected processGetDataOfflineTicket(response: HttpResponseBase): Observable<ApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResult>(null as any);
    }

    dongBoVeOffline(listData: ThongTinVeOffline[]): Observable<ApiResult> {
        let url_ = this.baseUrl + "/api/MobileTicket/DongBoVeOffline";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDongBoVeOffline(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDongBoVeOffline(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResult>;
        }));
    }

    protected processDongBoVeOffline(response: HttpResponseBase): Observable<ApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResult>(null as any);
    }
}

@Injectable()
export class InvoiceLookupClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    index(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/tra-cuu-hoa-don";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIndex(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIndex(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processIndex(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    traCuuHoaDon(matracuu: string | null | undefined, captcha: string | null | undefined, mst: string | null | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/tra-cuu-hoa-don/getdata?";
        if (matracuu !== undefined && matracuu !== null)
            url_ += "matracuu=" + encodeURIComponent("" + matracuu) + "&";
        if (captcha !== undefined && captcha !== null)
            url_ += "captcha=" + encodeURIComponent("" + captcha) + "&";
        if (mst !== undefined && mst !== null)
            url_ += "mst=" + encodeURIComponent("" + mst) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTraCuuHoaDon(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTraCuuHoaDon(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processTraCuuHoaDon(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }

    viewHoaDon(id: string | null | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/tra-cuu-hoa-don/viewinvoice?";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processViewHoaDon(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processViewHoaDon(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processViewHoaDon(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }
}

@Injectable()
export class IntegratedTicketClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    luuThongTinVe(model: ThongTinVeRequest): Observable<ApiResult> {
        let url_ = this.baseUrl + "/api/IntegratedTicket/sendthongtinve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLuuThongTinVe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLuuThongTinVe(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResult>;
        }));
    }

    protected processLuuThongTinVe(response: HttpResponseBase): Observable<ApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResult>(null as any);
    }

    xuatHdLoi(): Observable<ApiResult> {
        let url_ = this.baseUrl + "/api/IntegratedTicket/xuatlaihd";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXuatHdLoi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXuatHdLoi(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResult>;
        }));
    }

    protected processXuatHdLoi(response: HttpResponseBase): Observable<ApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResult>(null as any);
    }
}

@Injectable()
export class ClientAccountClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    changePassword(model: ResetPasswordVm): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/ClientAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }
}

@Injectable()
export class ClientInVeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    inListVe(hopdongVeId: string | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/ClientInVe/inlistve?";
        if (hopdongVeId === null)
            throw new Error("The parameter 'hopdongVeId' cannot be null.");
        else if (hopdongVeId !== undefined)
            url_ += "hopdongVeId=" + encodeURIComponent("" + hopdongVeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInListVe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInListVe(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processInListVe(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }
}

@Injectable()
export class ClientLoaiVesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    getDanhSachLoaiVes(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/ClientLoaiVes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDanhSachLoaiVes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDanhSachLoaiVes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetDanhSachLoaiVes(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }
}

@Injectable()
export class ClientLoginClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    authenticate(model: AuthenticateRequest): Observable<string> {
        let url_ = this.baseUrl + "/api/ClientLogin/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class AdminAccountClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    getAll(): Observable<AdminManagerUserDto[]> {
        let url_ = this.baseUrl + "/api/adminaccount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminManagerUserDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminManagerUserDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AdminManagerUserDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AdminManagerUserDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminManagerUserDto[]>(null as any);
    }

    create(model: NhanVienDto): Observable<ApiResult> {
        let url_ = this.baseUrl + "/api/adminaccount/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResult>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResult>(null as any);
    }

    delete(request: DeleteModelRequest): Observable<ApiResult> {
        let url_ = this.baseUrl + "/api/adminaccount/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResult>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResult>(null as any);
    }

    unlockAccount(userId: any): Observable<any> {
        return this.http
        .put(this.baseUrl  + `/api/adminaccount/unlockaccount?UserId=${userId}`,null);
    }

    resetPassword(userId: string | null | undefined): Observable<ApiResult> {
        let url_ = this.baseUrl + "/api/adminaccount/reset?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResult>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResult>(null as any);
    }

    addAccessUser(tenantId: number | undefined, userId: string | undefined, accessUserId: string | undefined): Observable<ApiResult> {
        let url_ = this.baseUrl + "/api/adminaccount/addaccessuser?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (accessUserId === null)
            throw new Error("The parameter 'accessUserId' cannot be null.");
        else if (accessUserId !== undefined)
            url_ += "accessUserId=" + encodeURIComponent("" + accessUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddAccessUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddAccessUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResult>;
        }));
    }

    protected processAddAccessUser(response: HttpResponseBase): Observable<ApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResult>(null as any);
    }

    deleteAccessUser(lienKetTaiKhoanId: string | undefined): Observable<ApiResult> {
        let url_ = this.baseUrl + "/api/adminaccount/deleteaccessuser?";
        if (lienKetTaiKhoanId === null)
            throw new Error("The parameter 'lienKetTaiKhoanId' cannot be null.");
        else if (lienKetTaiKhoanId !== undefined)
            url_ += "lienKetTaiKhoanId=" + encodeURIComponent("" + lienKetTaiKhoanId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAccessUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAccessUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResult>;
        }));
    }

    protected processDeleteAccessUser(response: HttpResponseBase): Observable<ApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResult>(null as any);
    }
}

@Injectable()
export class AdminDashboardClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    getChiTietVeLoi(tenantId: number): Observable<ChiTietVeLoiVm> {
        let url_ = this.baseUrl + "/api/admindashboard/chitietveloi";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tenantId);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChiTietVeLoi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChiTietVeLoi(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChiTietVeLoiVm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChiTietVeLoiVm>;
        }));
    }

    protected processGetChiTietVeLoi(response: HttpResponseBase): Observable<ChiTietVeLoiVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChiTietVeLoiVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChiTietVeLoiVm>(null as any);
    }

    xuatLaiHdErr5(): Observable<ApiResult> {
        let url_ = this.baseUrl + "/api/admindashboard/xuatlaihd";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXuatLaiHdErr5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXuatLaiHdErr5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResult>;
        }));
    }

    protected processXuatLaiHdErr5(response: HttpResponseBase): Observable<ApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResult>(null as any);
    }
}

@Injectable()
export class AdminLoaiVeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    getDanhSachLoaiVe(tenantId: number | undefined, request: PagingRequest = null): Observable<LoaiVe[]> {
        let qs = '';
        if (request) {
            qs = Object.keys(request)
                .map(key => `${key}=${request[key]}`)
                .join('&');
        }
        return this.http
            .get<LoaiVe[]>(this.baseUrl + `/api/adminloaive/getdsloaive?TenantId=${tenantId}&${qs}`)
            .pipe(catchError(() => of([])));

    }

    protected processGetDanhSachLoaiVe(response: HttpResponseBase): Observable<LoaiVe[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LoaiVe.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoaiVe[]>(null as any);
    }

    create(loaiVe: LoaiVe): Observable<ApiResult> {
        let url_ = this.baseUrl + "/api/adminloaive/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loaiVe);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResult>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResult>(null as any);
    }

    edit(loaiVe: LoaiVe): Observable<ApiResult> {
        let url_ = this.baseUrl + "/api/adminloaive/edit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loaiVe);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResult>;
        }));
    }

    protected processEdit(response: HttpResponseBase): Observable<ApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResult>(null as any);
    }

    delete(request: DeleteModelRequest): Observable<ApiResult> {
        let url_ = this.baseUrl + "/api/adminloaive/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResult>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResult>(null as any);
    }
}

@Injectable()
export class AdminMauVeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    filterMauVe(tenantId: any, request: PagingRequest = null): Observable<MauVe[]> {
        let qs = '';
        if (request) {
            qs = Object.keys(request)
                .map(key => `${key}=${request[key]}`)
                .join('&');
        }
        return this.http
        .get<MauVe[]>(this.baseUrl  + `/api/adminmauve/filter?TenantId=${tenantId}&${qs}`)
        .pipe(catchError(() => of([])));
    }

    getAllByTenantId(tenantId: number | undefined): Observable<MauVe[]> {
        let url_ = this.baseUrl + "/api/adminmauve?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByTenantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByTenantId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MauVe[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MauVe[]>;
        }));
    }

    protected processGetAllByTenantId(response: HttpResponseBase): Observable<MauVe[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MauVe.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MauVe[]>(null as any);
    }

    create(mauVe: MauVe): Observable<ApiResult> {
        let url_ = this.baseUrl + "/api/adminmauve/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(mauVe);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResult>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResult>(null as any);
    }

    edit(id: number | undefined, mauVe: MauVe): Observable<ApiResult> {
        let url_ = this.baseUrl + "/api/adminmauve/edit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(mauVe);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResult>;
        }));
    }

    protected processEdit(response: HttpResponseBase): Observable<ApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResult>(null as any);
    }

    delete(id: number | undefined, request: DeleteModelRequest): Observable<ApiResult> {
        let url_ = this.baseUrl + "/api/adminmauve/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResult>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResult>(null as any);
    }
}

@Injectable()
export class AdminReportClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    baoCaoSanLuongVe(request: BaoCaoRequest): Observable<DtResultOfBaoCaoSanLuongVeVm> {
        let url_ = this.baseUrl + "/api/adminreport/baocaosanluongve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };
    

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBaoCaoSanLuongVe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBaoCaoSanLuongVe(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DtResultOfBaoCaoSanLuongVeVm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DtResultOfBaoCaoSanLuongVeVm>;
        }));
    }

    baoCaoSoLuongVePhatHanh(nam): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/adminreport/excelsoluongvephathanh";
        url_ = url_.replace(/[?&]$/, "");
        let item : any = {
            Nam : nam
        }
        const content_ = JSON.stringify(item);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };
        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExcelBaoCaoSanLuongVe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExcelBaoCaoSanLuongVe(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    baoCaoSoLuongKhacHang(nam): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/adminreport/excelsoluongkhachhang";
        url_ = url_.replace(/[?&]$/, "");
        let item : any = {
            Nam : nam
        }
        const content_ = JSON.stringify(item);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };
        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExcelBaoCaoSanLuongVe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExcelBaoCaoSanLuongVe(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processBaoCaoSanLuongVe(response: HttpResponseBase): Observable<DtResultOfBaoCaoSanLuongVeVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DtResultOfBaoCaoSanLuongVeVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DtResultOfBaoCaoSanLuongVeVm>(null as any);
    }

    excelBaoCaoSanLuongVe(request: BaoCaoRequest): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/adminreport/excelsanluongve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExcelBaoCaoSanLuongVe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExcelBaoCaoSanLuongVe(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processExcelBaoCaoSanLuongVe(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;
        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(null as any);
    }
}

@Injectable()
export class AdminTenantClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    getTenantById(tenantId: number | undefined): Observable<Tenant> {
        let url_ = this.baseUrl + "/api/admintenant/getdstenantbyid?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Tenant>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Tenant>;
        }));
    }

    protected processGetTenantById(response: HttpResponseBase): Observable<Tenant> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Tenant.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Tenant>(null as any);
    }

    getDanhSachTenant(pageIndex: number | null | undefined, pageSize: number | null | undefined, searchText: string | null | undefined, searchDate: string | null | undefined, tenantGroupId: number | null | undefined, status: boolean | null | undefined, tenantId: number | null | undefined): Observable<DtResultOfTenant> {
        let url_ = this.baseUrl + "/api/admintenant/getdstenant?";
        if (pageIndex !== undefined && pageIndex !== null)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (searchDate !== undefined && searchDate !== null)
            url_ += "searchDate=" + encodeURIComponent("" + searchDate) + "&";
        if (tenantGroupId !== undefined && tenantGroupId !== null)
            url_ += "TenantGroupId=" + encodeURIComponent("" + tenantGroupId) + "&";
        if (status !== undefined && status !== null)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDanhSachTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDanhSachTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DtResultOfTenant>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DtResultOfTenant>;
        }));
    }

    protected processGetDanhSachTenant(response: HttpResponseBase): Observable<DtResultOfTenant> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DtResultOfTenant.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DtResultOfTenant>(null as any);
    }

    createTenant(heThong: KhoiTaoHeThongDto): Observable<ApiResult> {
        let url_ = this.baseUrl + "/api/admintenant/createtenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(heThong);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResult>;
        }));
    }

    protected processCreateTenant(response: HttpResponseBase): Observable<ApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResult>(null as any);
    }

    editTenant(tenant: Tenant): Observable<ApiResult> {
        let url_ = this.baseUrl + "/api/admintenant/edittenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tenant);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResult>;
        }));
    }

    protected processEditTenant(response: HttpResponseBase): Observable<ApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResult>(null as any);
    }

    deleteTenant(request: DeleteModelRequest): Observable<ApiResult> {
        let url_ = this.baseUrl + "/api/admintenant/deletetenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResult>;
        }));
    }

    protected processDeleteTenant(response: HttpResponseBase): Observable<ApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResult>(null as any);
    }

    resetTenant(tenant: Tenant): Observable<ApiResult> {
        let url_ = this.baseUrl + "/api/admintenant/resettenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tenant);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResult>;
        }));
    }

    protected processResetTenant(response: HttpResponseBase): Observable<ApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResult>(null as any);
    }

    getTenantByGroupId(tenantGroupId: number | undefined): Observable<AdminTenantGroupDto[]> {
        let url_ = this.baseUrl + "/api/admintenant/gettenantbygroupid?";
        if (tenantGroupId === null)
            throw new Error("The parameter 'tenantGroupId' cannot be null.");
        else if (tenantGroupId !== undefined)
            url_ += "tenantGroupId=" + encodeURIComponent("" + tenantGroupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantByGroupId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantByGroupId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminTenantGroupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminTenantGroupDto[]>;
        }));
    }

    protected processGetTenantByGroupId(response: HttpResponseBase): Observable<AdminTenantGroupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AdminTenantGroupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminTenantGroupDto[]>(null as any);
    }
}

export class ResetPasswordVm implements IResetPasswordVm {
    currentPassword!: string;
    password!: string;
    confirmPassword?: string | null;

    constructor(data?: IResetPasswordVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"] !== undefined ? _data["currentPassword"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
            this.confirmPassword = _data["confirmPassword"] !== undefined ? _data["confirmPassword"] : <any>null;
        }
    }

    static fromJS(data: any): ResetPasswordVm {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword !== undefined ? this.currentPassword : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["confirmPassword"] = this.confirmPassword !== undefined ? this.confirmPassword : <any>null;
        return data;
    }
}

export interface IResetPasswordVm {
    currentPassword: string;
    password: string;
    confirmPassword?: string | null;
}

export class KhoiTaoHeThongDto implements IKhoiTaoHeThongDto {
    tenantId!: number;
    tenDonVi?: string | null;
    tenantCode?: string | null;
    domain?: string | null;
    isVeHopDong!: boolean;
    isHasDichVu!: boolean;
    isXuatHoaDonKhiBan!: boolean;
    isNVBanVeFree!: boolean;
    isRelease!: boolean;
    prefixMV?: string | null;
    loaiHoaDon!: EnumLoaiHoaDon;
    giaoDienBanVe!: EnumGiaoDienBanVe;
    isCanDeleteInvoice!: boolean;
    isUseMaKiemSoat!: boolean;
    isMaKiemSoatLV!: boolean;
    isHasGiamThueTheoQD!: boolean;
    thoiGianKhoiTaoHT?: Date | null;
    thoiGianChayChinhThuc?: Date | null;
    maSoThue?: string | null;
    diaChi?: string | null;
    soDienThoai?: string | null;

    constructor(data?: IKhoiTaoHeThongDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"] !== undefined ? _data["tenantId"] : <any>null;
            this.tenDonVi = _data["tenDonVi"] !== undefined ? _data["tenDonVi"] : <any>null;
            this.tenantCode = _data["tenantCode"] !== undefined ? _data["tenantCode"] : <any>null;
            this.domain = _data["domain"] !== undefined ? _data["domain"] : <any>null;
            this.isVeHopDong = _data["isVeHopDong"] !== undefined ? _data["isVeHopDong"] : <any>null;
            this.isHasDichVu = _data["isHasDichVu"] !== undefined ? _data["isHasDichVu"] : <any>null;
            this.isXuatHoaDonKhiBan = _data["isXuatHoaDonKhiBan"] !== undefined ? _data["isXuatHoaDonKhiBan"] : <any>null;
            this.isNVBanVeFree = _data["isNVBanVeFree"] !== undefined ? _data["isNVBanVeFree"] : <any>null;
            this.isRelease = _data["isRelease"] !== undefined ? _data["isRelease"] : <any>null;
            this.prefixMV = _data["prefixMV"] !== undefined ? _data["prefixMV"] : <any>null;
            this.loaiHoaDon = _data["loaiHoaDon"] !== undefined ? _data["loaiHoaDon"] : <any>null;
            this.giaoDienBanVe = _data["giaoDienBanVe"] !== undefined ? _data["giaoDienBanVe"] : <any>null;
            this.isCanDeleteInvoice = _data["isCanDeleteInvoice"] !== undefined ? _data["isCanDeleteInvoice"] : <any>null;
            this.isUseMaKiemSoat = _data["isUseMaKiemSoat"] !== undefined ? _data["isUseMaKiemSoat"] : <any>null;
            this.isMaKiemSoatLV = _data["isMaKiemSoatLV"] !== undefined ? _data["isMaKiemSoatLV"] : <any>null;
            this.isHasGiamThueTheoQD = _data["isHasGiamThueTheoQD"] !== undefined ? _data["isHasGiamThueTheoQD"] : <any>null;
            this.thoiGianKhoiTaoHT = _data["thoiGianKhoiTaoHT"] ? new Date(_data["thoiGianKhoiTaoHT"].toString()) : <any>null;
            this.thoiGianChayChinhThuc = _data["thoiGianChayChinhThuc"] ? new Date(_data["thoiGianChayChinhThuc"].toString()) : <any>null;
            this.maSoThue = _data["maSoThue"] !== undefined ? _data["maSoThue"] : <any>null;
            this.diaChi = _data["diaChi"] !== undefined ? _data["diaChi"] : <any>null;
            this.soDienThoai = _data["soDienThoai"] !== undefined ? _data["soDienThoai"] : <any>null;
        }
    }

    static fromJS(data: any): KhoiTaoHeThongDto {
        data = typeof data === 'object' ? data : {};
        let result = new KhoiTaoHeThongDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId !== undefined ? this.tenantId : <any>null;
        data["tenDonVi"] = this.tenDonVi !== undefined ? this.tenDonVi : <any>null;
        data["tenantCode"] = this.tenantCode !== undefined ? this.tenantCode : <any>null;
        data["domain"] = this.domain !== undefined ? this.domain : <any>null;
        data["isVeHopDong"] = this.isVeHopDong !== undefined ? this.isVeHopDong : <any>null;
        data["isHasDichVu"] = this.isHasDichVu !== undefined ? this.isHasDichVu : <any>null;
        data["isXuatHoaDonKhiBan"] = this.isXuatHoaDonKhiBan !== undefined ? this.isXuatHoaDonKhiBan : <any>null;
        data["isNVBanVeFree"] = this.isNVBanVeFree !== undefined ? this.isNVBanVeFree : <any>null;
        data["isRelease"] = this.isRelease !== undefined ? this.isRelease : <any>null;
        data["prefixMV"] = this.prefixMV !== undefined ? this.prefixMV : <any>null;
        data["loaiHoaDon"] = this.loaiHoaDon !== undefined ? this.loaiHoaDon : <any>null;
        data["giaoDienBanVe"] = this.giaoDienBanVe !== undefined ? this.giaoDienBanVe : <any>null;
        data["isCanDeleteInvoice"] = this.isCanDeleteInvoice !== undefined ? this.isCanDeleteInvoice : <any>null;
        data["isUseMaKiemSoat"] = this.isUseMaKiemSoat !== undefined ? this.isUseMaKiemSoat : <any>null;
        data["isMaKiemSoatLV"] = this.isMaKiemSoatLV !== undefined ? this.isMaKiemSoatLV : <any>null;
        data["isHasGiamThueTheoQD"] = this.isHasGiamThueTheoQD !== undefined ? this.isHasGiamThueTheoQD : <any>null;
        data["thoiGianKhoiTaoHT"] = this.thoiGianKhoiTaoHT ? this.thoiGianKhoiTaoHT.toISOString() : <any>null;
        data["thoiGianChayChinhThuc"] = this.thoiGianChayChinhThuc ? this.thoiGianChayChinhThuc.toISOString() : <any>null;
        data["maSoThue"] = this.maSoThue !== undefined ? this.maSoThue : <any>null;
        data["diaChi"] = this.diaChi !== undefined ? this.diaChi : <any>null;
        data["soDienThoai"] = this.soDienThoai !== undefined ? this.soDienThoai : <any>null;
        return data;
    }
}

export interface IKhoiTaoHeThongDto {
    tenantId: number;
    tenDonVi?: string | null;
    tenantCode?: string | null;
    domain?: string | null;
    isVeHopDong: boolean;
    isHasDichVu: boolean;
    isXuatHoaDonKhiBan: boolean;
    isNVBanVeFree: boolean;
    isRelease: boolean;
    prefixMV?: string | null;
    loaiHoaDon: EnumLoaiHoaDon;
    giaoDienBanVe: EnumGiaoDienBanVe;
    isCanDeleteInvoice: boolean;
    isUseMaKiemSoat: boolean;
    isMaKiemSoatLV: boolean;
    isHasGiamThueTheoQD: boolean;
    thoiGianKhoiTaoHT?: Date | null;
    thoiGianChayChinhThuc?: Date | null;
    maSoThue?: string | null;
    diaChi?: string | null;
    soDienThoai?: string | null;
}

export enum EnumLoaiHoaDon {
    VNPT = "VNPT",
    FPT = "FPT",
    VIETTEL = "VIETTEL",
}

export enum EnumGiaoDienBanVe {
    GiaoDien1 = "GiaoDien1",
    GiaoDien2 = "GiaoDien2",
    GiaoDien3 = "GiaoDien3",
    GiaoDien4 = "GiaoDien4",
}

export class Tenant implements ITenant {
    tenantId!: number;
    tenDonVi?: string | null;
    tenantCode?: string | null;
    domain?: string | null;
    isVeHopDong!: boolean;
    isHasDichVu!: boolean;
    isXuatHoaDonKhiBan!: boolean;
    isNVBanVeFree!: boolean;
    isRelease!: boolean;
    prefixMV?: string | null;
    loaiHoaDon!: EnumLoaiHoaDon;
    giaoDienBanVe!: EnumGiaoDienBanVe;
    isCanDeleteInvoice!: boolean;
    isUseMaKiemSoat!: boolean;
    isMaKiemSoatLV!: boolean;
    isHasGiamThueTheoQD!: boolean;
    isGioiHanIn!: boolean;
    isAsyncInvoice!: boolean;
    noPrintInvoiceAfterSell!: boolean;
    isShowLookupInvoice!: boolean;
    isShowHistoryTicket!: boolean;
    isCanBeAccessUser!: boolean;
    thoiGianKhoiTaoHT?: Date | null;
    thoiGianChayChinhThuc?: Date | null;
    maSoThue?: string | null;

    constructor(data?: ITenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"] !== undefined ? _data["tenantId"] : <any>null;
            this.tenDonVi = _data["tenDonVi"] !== undefined ? _data["tenDonVi"] : <any>null;
            this.tenantCode = _data["tenantCode"] !== undefined ? _data["tenantCode"] : <any>null;
            this.domain = _data["domain"] !== undefined ? _data["domain"] : <any>null;
            this.isVeHopDong = _data["isVeHopDong"] !== undefined ? _data["isVeHopDong"] : <any>null;
            this.isHasDichVu = _data["isHasDichVu"] !== undefined ? _data["isHasDichVu"] : <any>null;
            this.isXuatHoaDonKhiBan = _data["isXuatHoaDonKhiBan"] !== undefined ? _data["isXuatHoaDonKhiBan"] : <any>null;
            this.isNVBanVeFree = _data["isNVBanVeFree"] !== undefined ? _data["isNVBanVeFree"] : <any>null;
            this.isRelease = _data["isRelease"] !== undefined ? _data["isRelease"] : <any>null;
            this.prefixMV = _data["prefixMV"] !== undefined ? _data["prefixMV"] : <any>null;
            this.loaiHoaDon = _data["loaiHoaDon"] !== undefined ? _data["loaiHoaDon"] : <any>null;
            this.giaoDienBanVe = _data["giaoDienBanVe"] !== undefined ? _data["giaoDienBanVe"] : <any>null;
            this.isCanDeleteInvoice = _data["isCanDeleteInvoice"] !== undefined ? _data["isCanDeleteInvoice"] : <any>null;
            this.isUseMaKiemSoat = _data["isUseMaKiemSoat"] !== undefined ? _data["isUseMaKiemSoat"] : <any>null;
            this.isMaKiemSoatLV = _data["isMaKiemSoatLV"] !== undefined ? _data["isMaKiemSoatLV"] : <any>null;
            this.isHasGiamThueTheoQD = _data["isHasGiamThueTheoQD"] !== undefined ? _data["isHasGiamThueTheoQD"] : <any>null;
            this.isGioiHanIn = _data["isGioiHanIn"] !== undefined ? _data["isGioiHanIn"] : <any>null;
            this.isAsyncInvoice = _data["isAsyncInvoice"] !== undefined ? _data["isAsyncInvoice"] : <any>null;
            this.noPrintInvoiceAfterSell = _data["noPrintInvoiceAfterSell"] !== undefined ? _data["noPrintInvoiceAfterSell"] : <any>null;
            this.isShowLookupInvoice = _data["isShowLookupInvoice"] !== undefined ? _data["isShowLookupInvoice"] : <any>null;
            this.isShowHistoryTicket = _data["isShowHistoryTicket"] !== undefined ? _data["isShowHistoryTicket"] : <any>null;
            this.isCanBeAccessUser = _data["isCanBeAccessUser"] !== undefined ? _data["isCanBeAccessUser"] : <any>null;
            this.thoiGianKhoiTaoHT = _data["thoiGianKhoiTaoHT"] ? new Date(_data["thoiGianKhoiTaoHT"].toString()) : <any>null;
            this.thoiGianChayChinhThuc = _data["thoiGianChayChinhThuc"] ? new Date(_data["thoiGianChayChinhThuc"].toString()) : <any>null;
            this.maSoThue = _data["maSoThue"] !== undefined ? _data["maSoThue"] : <any>null;
        }
    }

    static fromJS(data: any): Tenant {
        data = typeof data === 'object' ? data : {};
        let result = new Tenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId !== undefined ? this.tenantId : <any>null;
        data["tenDonVi"] = this.tenDonVi !== undefined ? this.tenDonVi : <any>null;
        data["tenantCode"] = this.tenantCode !== undefined ? this.tenantCode : <any>null;
        data["domain"] = this.domain !== undefined ? this.domain : <any>null;
        data["isVeHopDong"] = this.isVeHopDong !== undefined ? this.isVeHopDong : <any>null;
        data["isHasDichVu"] = this.isHasDichVu !== undefined ? this.isHasDichVu : <any>null;
        data["isXuatHoaDonKhiBan"] = this.isXuatHoaDonKhiBan !== undefined ? this.isXuatHoaDonKhiBan : <any>null;
        data["isNVBanVeFree"] = this.isNVBanVeFree !== undefined ? this.isNVBanVeFree : <any>null;
        data["isRelease"] = this.isRelease !== undefined ? this.isRelease : <any>null;
        data["prefixMV"] = this.prefixMV !== undefined ? this.prefixMV : <any>null;
        data["loaiHoaDon"] = this.loaiHoaDon !== undefined ? this.loaiHoaDon : <any>null;
        data["giaoDienBanVe"] = this.giaoDienBanVe !== undefined ? this.giaoDienBanVe : <any>null;
        data["isCanDeleteInvoice"] = this.isCanDeleteInvoice !== undefined ? this.isCanDeleteInvoice : <any>null;
        data["isUseMaKiemSoat"] = this.isUseMaKiemSoat !== undefined ? this.isUseMaKiemSoat : <any>null;
        data["isMaKiemSoatLV"] = this.isMaKiemSoatLV !== undefined ? this.isMaKiemSoatLV : <any>null;
        data["isHasGiamThueTheoQD"] = this.isHasGiamThueTheoQD !== undefined ? this.isHasGiamThueTheoQD : <any>null;
        data["isGioiHanIn"] = this.isGioiHanIn !== undefined ? this.isGioiHanIn : <any>null;
        data["isAsyncInvoice"] = this.isAsyncInvoice !== undefined ? this.isAsyncInvoice : <any>null;
        data["noPrintInvoiceAfterSell"] = this.noPrintInvoiceAfterSell !== undefined ? this.noPrintInvoiceAfterSell : <any>null;
        data["isShowLookupInvoice"] = this.isShowLookupInvoice !== undefined ? this.isShowLookupInvoice : <any>null;
        data["isShowHistoryTicket"] = this.isShowHistoryTicket !== undefined ? this.isShowHistoryTicket : <any>null;
        data["isCanBeAccessUser"] = this.isCanBeAccessUser !== undefined ? this.isCanBeAccessUser : <any>null;
        data["thoiGianKhoiTaoHT"] = this.thoiGianKhoiTaoHT ? this.thoiGianKhoiTaoHT.toISOString() : <any>null;
        data["thoiGianChayChinhThuc"] = this.thoiGianChayChinhThuc ? this.thoiGianChayChinhThuc.toISOString() : <any>null;
        data["maSoThue"] = this.maSoThue !== undefined ? this.maSoThue : <any>null;
        return data;
    }
}

export interface ITenant {
    tenantId: number;
    tenDonVi?: string | null;
    tenantCode?: string | null;
    domain?: string | null;
    isVeHopDong: boolean;
    isHasDichVu: boolean;
    isXuatHoaDonKhiBan: boolean;
    isNVBanVeFree: boolean;
    isRelease: boolean;
    prefixMV?: string | null;
    loaiHoaDon: EnumLoaiHoaDon;
    giaoDienBanVe: EnumGiaoDienBanVe;
    isCanDeleteInvoice: boolean;
    isUseMaKiemSoat: boolean;
    isMaKiemSoatLV: boolean;
    isHasGiamThueTheoQD: boolean;
    isGioiHanIn: boolean;
    isAsyncInvoice: boolean;
    noPrintInvoiceAfterSell: boolean;
    isShowLookupInvoice: boolean;
    isShowHistoryTicket: boolean;
    isCanBeAccessUser: boolean;
    thoiGianKhoiTaoHT?: Date | null;
    thoiGianChayChinhThuc?: Date | null;
    maSoThue?: string | null;
}

export class DeleteModelRequest implements IDeleteModelRequest {
    id?: number | null;
    guid?: string | null;
    tenantId?: number | null;
    tenantCode?: string | null;
    stringId?: string | null;

    constructor(data?: IDeleteModelRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.guid = _data["guid"] !== undefined ? _data["guid"] : <any>null;
            this.tenantId = _data["tenantId"] !== undefined ? _data["tenantId"] : <any>null;
            this.tenantCode = _data["tenantCode"] !== undefined ? _data["tenantCode"] : <any>null;
            this.stringId = _data["stringId"] !== undefined ? _data["stringId"] : <any>null;
        }
    }

    static fromJS(data: any): DeleteModelRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteModelRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["guid"] = this.guid !== undefined ? this.guid : <any>null;
        data["tenantId"] = this.tenantId !== undefined ? this.tenantId : <any>null;
        data["tenantCode"] = this.tenantCode !== undefined ? this.tenantCode : <any>null;
        data["stringId"] = this.stringId !== undefined ? this.stringId : <any>null;
        return data;
    }
}

export interface IDeleteModelRequest {
    id?: number | null;
    guid?: string | null;
    tenantId?: number | null;
    tenantCode?: string | null;
    stringId?: string | null;
}

export class AuditableEntity implements IAuditableEntity {
    createdBy?: string | null;
    createdDate?: Date | null;
    lastModifiedBy?: string | null;
    lastModified?: Date | null;
    ipAddress?: string | null;
    tenantId?: number | null;
    isDeleted!: boolean;

    constructor(data?: IAuditableEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"] !== undefined ? _data["createdBy"] : <any>null;
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>null;
            this.lastModifiedBy = _data["lastModifiedBy"] !== undefined ? _data["lastModifiedBy"] : <any>null;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>null;
            this.ipAddress = _data["ipAddress"] !== undefined ? _data["ipAddress"] : <any>null;
            this.tenantId = _data["tenantId"] !== undefined ? _data["tenantId"] : <any>null;
            this.isDeleted = _data["isDeleted"] !== undefined ? _data["isDeleted"] : <any>null;
        }
    }

    static fromJS(data: any): AuditableEntity {
        data = typeof data === 'object' ? data : {};
        let result = new AuditableEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy !== undefined ? this.createdBy : <any>null;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>null;
        data["lastModifiedBy"] = this.lastModifiedBy !== undefined ? this.lastModifiedBy : <any>null;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>null;
        data["ipAddress"] = this.ipAddress !== undefined ? this.ipAddress : <any>null;
        data["tenantId"] = this.tenantId !== undefined ? this.tenantId : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        return data;
    }
}

export interface IAuditableEntity {
    createdBy?: string | null;
    createdDate?: Date | null;
    lastModifiedBy?: string | null;
    lastModified?: Date | null;
    ipAddress?: string | null;
    tenantId?: number | null;
    isDeleted: boolean;
}

export class LoaiVe extends AuditableEntity implements ILoaiVe {
    loaiVeId!: number;
    tenLoaiVe?: string | null;
    tenHienThi?: string | null;
    giaTien!: number;
    giaTruocThue?: number | null;
    ngayHieuLuc?: Date | null;
    ngayHetHanHieuLuc?: Date | null;
    soLanSuDung?: number | null;
    isSuDungTrongNgay!: boolean;
    gioKetThucTrongNgay?: string | null;
    soNgayCoTheSD?: number | null;
    chiTietDichVu?: string | null;
    ghiChu?: string | null;
    isActive!: boolean;
    isUseImage!: boolean;
    phanLoaiVe!: EnumCauHinhVe;
    nhomDichVuId?: number | null;
    nhomDichVu?: NhomDichVu | null;
    mauVeId!: number;
    mauVe?: MauVe | null;
    ves?: Ve[] | null;
    loaiVeDichVus?: LoaiVeDichVu[] | null;
    tenantId?: number | null;
    mauSo?: string | null;
    kyHieu?: string | null;
    vat?: number | null;
    orderBy?: number | null;
    loaiTienTe!: EnumLoaiTienTe;
    isGiamTru!: boolean;
    maGiamTru?: string | null;
    phanTramGiamTru?: number | null;
    soTienGiamTru?: number | null;
    textGiamTru?: string | null;
    baoHiemHanhKhach?: number | null;
    nhanVienLoaiVes?: NhanVienLoaiVe[] | null;
    soNgayCoTheSDVeKhuyenMai?: number | null;
    gioKetThucVeKhuyenMai?: string | null;

    constructor(data?: ILoaiVe) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.loaiVeId = _data["loaiVeId"] !== undefined ? _data["loaiVeId"] : <any>null;
            this.tenLoaiVe = _data["tenLoaiVe"] !== undefined ? _data["tenLoaiVe"] : <any>null;
            this.tenHienThi = _data["tenHienThi"] !== undefined ? _data["tenHienThi"] : <any>null;
            this.giaTien = _data["giaTien"] !== undefined ? _data["giaTien"] : <any>null;
            this.giaTruocThue = _data["giaTruocThue"] !== undefined ? _data["giaTruocThue"] : <any>null;
            this.ngayHieuLuc = _data["ngayHieuLuc"] ? new Date(_data["ngayHieuLuc"].toString()) : <any>null;
            this.ngayHetHanHieuLuc = _data["ngayHetHanHieuLuc"] ? new Date(_data["ngayHetHanHieuLuc"].toString()) : <any>null;
            this.soLanSuDung = _data["soLanSuDung"] !== undefined ? _data["soLanSuDung"] : <any>null;
            this.isSuDungTrongNgay = _data["isSuDungTrongNgay"] !== undefined ? _data["isSuDungTrongNgay"] : <any>null;
            this.gioKetThucTrongNgay = _data["gioKetThucTrongNgay"] !== undefined ? _data["gioKetThucTrongNgay"] : <any>null;
            this.soNgayCoTheSD = _data["soNgayCoTheSD"] !== undefined ? _data["soNgayCoTheSD"] : <any>null;
            this.chiTietDichVu = _data["chiTietDichVu"] !== undefined ? _data["chiTietDichVu"] : <any>null;
            this.ghiChu = _data["ghiChu"] !== undefined ? _data["ghiChu"] : <any>null;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
            this.isUseImage = _data["isUseImage"] !== undefined ? _data["isUseImage"] : <any>null;
            this.phanLoaiVe = _data["phanLoaiVe"] !== undefined ? _data["phanLoaiVe"] : <any>null;
            this.nhomDichVuId = _data["nhomDichVuId"] !== undefined ? _data["nhomDichVuId"] : <any>null;
            this.nhomDichVu = _data["nhomDichVu"] ? NhomDichVu.fromJS(_data["nhomDichVu"]) : <any>null;
            this.mauVeId = _data["mauVeId"] !== undefined ? _data["mauVeId"] : <any>null;
            this.mauVe = _data["mauVe"] ? MauVe.fromJS(_data["mauVe"]) : <any>null;
            if (Array.isArray(_data["ves"])) {
                this.ves = [] as any;
                for (let item of _data["ves"])
                    this.ves!.push(Ve.fromJS(item));
            }
            else {
                this.ves = <any>null;
            }
            if (Array.isArray(_data["loaiVeDichVus"])) {
                this.loaiVeDichVus = [] as any;
                for (let item of _data["loaiVeDichVus"])
                    this.loaiVeDichVus!.push(LoaiVeDichVu.fromJS(item));
            }
            else {
                this.loaiVeDichVus = <any>null;
            }
            this.tenantId = _data["tenantId"] !== undefined ? _data["tenantId"] : <any>null;
            this.mauSo = _data["mauSo"] !== undefined ? _data["mauSo"] : <any>null;
            this.kyHieu = _data["kyHieu"] !== undefined ? _data["kyHieu"] : <any>null;
            this.vat = _data["vat"] !== undefined ? _data["vat"] : <any>null;
            this.orderBy = _data["orderBy"] !== undefined ? _data["orderBy"] : <any>null;
            this.loaiTienTe = _data["loaiTienTe"] !== undefined ? _data["loaiTienTe"] : <any>null;
            this.isGiamTru = _data["isGiamTru"] !== undefined ? _data["isGiamTru"] : <any>null;
            this.maGiamTru = _data["maGiamTru"] !== undefined ? _data["maGiamTru"] : <any>null;
            this.phanTramGiamTru = _data["phanTramGiamTru"] !== undefined ? _data["phanTramGiamTru"] : <any>null;
            this.soTienGiamTru = _data["soTienGiamTru"] !== undefined ? _data["soTienGiamTru"] : <any>null;
            this.textGiamTru = _data["textGiamTru"] !== undefined ? _data["textGiamTru"] : <any>null;
            this.baoHiemHanhKhach = _data["baoHiemHanhKhach"] !== undefined ? _data["baoHiemHanhKhach"] : <any>null;
            if (Array.isArray(_data["nhanVienLoaiVes"])) {
                this.nhanVienLoaiVes = [] as any;
                for (let item of _data["nhanVienLoaiVes"])
                    this.nhanVienLoaiVes!.push(NhanVienLoaiVe.fromJS(item));
            }
            else {
                this.nhanVienLoaiVes = <any>null;
            }
        }
    }

    static override fromJS(data: any): LoaiVe {
        data = typeof data === 'object' ? data : {};
        let result = new LoaiVe();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loaiVeId"] = this.loaiVeId !== undefined ? this.loaiVeId : <any>null;
        data["tenLoaiVe"] = this.tenLoaiVe !== undefined ? this.tenLoaiVe : <any>null;
        data["tenHienThi"] = this.tenHienThi !== undefined ? this.tenHienThi : <any>null;
        data["giaTien"] = this.giaTien !== undefined ? this.giaTien : <any>null;
        data["giaTruocThue"] = this.giaTruocThue !== undefined ? this.giaTruocThue : <any>null;
        data["ngayHieuLuc"] = this.ngayHieuLuc ? this.ngayHieuLuc.toISOString() : <any>null;
        data["ngayHetHanHieuLuc"] = this.ngayHetHanHieuLuc ? this.ngayHetHanHieuLuc.toISOString() : <any>null;
        data["soLanSuDung"] = this.soLanSuDung !== undefined ? this.soLanSuDung : <any>null;
        data["isSuDungTrongNgay"] = this.isSuDungTrongNgay !== undefined ? this.isSuDungTrongNgay : <any>null;
        data["gioKetThucTrongNgay"] = this.gioKetThucTrongNgay !== undefined ? this.gioKetThucTrongNgay : <any>null;
        data["soNgayCoTheSD"] = this.soNgayCoTheSD !== undefined ? this.soNgayCoTheSD : <any>null;
        data["chiTietDichVu"] = this.chiTietDichVu !== undefined ? this.chiTietDichVu : <any>null;
        data["ghiChu"] = this.ghiChu !== undefined ? this.ghiChu : <any>null;
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        data["isUseImage"] = this.isUseImage !== undefined ? this.isUseImage : <any>null;
        data["phanLoaiVe"] = this.phanLoaiVe !== undefined ? this.phanLoaiVe : <any>null;
        data["nhomDichVuId"] = this.nhomDichVuId !== undefined ? this.nhomDichVuId : <any>null;
        data["nhomDichVu"] = this.nhomDichVu ? this.nhomDichVu.toJSON() : <any>null;
        data["mauVeId"] = this.mauVeId !== undefined ? this.mauVeId : <any>null;
        data["mauVe"] = this.mauVe ? this.mauVe.toJSON() : <any>null;
        if (Array.isArray(this.ves)) {
            data["ves"] = [];
            for (let item of this.ves)
                data["ves"].push(item.toJSON());
        }
        if (Array.isArray(this.loaiVeDichVus)) {
            data["loaiVeDichVus"] = [];
            for (let item of this.loaiVeDichVus)
                data["loaiVeDichVus"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId !== undefined ? this.tenantId : <any>null;
        data["mauSo"] = this.mauSo !== undefined ? this.mauSo : <any>null;
        data["kyHieu"] = this.kyHieu !== undefined ? this.kyHieu : <any>null;
        data["vat"] = this.vat !== undefined ? this.vat : <any>null;
        data["orderBy"] = this.orderBy !== undefined ? this.orderBy : <any>null;
        data["loaiTienTe"] = this.loaiTienTe !== undefined ? this.loaiTienTe : <any>null;
        data["isGiamTru"] = this.isGiamTru !== undefined ? this.isGiamTru : <any>null;
        data["maGiamTru"] = this.maGiamTru !== undefined ? this.maGiamTru : <any>null;
        data["phanTramGiamTru"] = this.phanTramGiamTru !== undefined ? this.phanTramGiamTru : <any>null;
        data["soTienGiamTru"] = this.soTienGiamTru !== undefined ? this.soTienGiamTru : <any>null;
        data["textGiamTru"] = this.textGiamTru !== undefined ? this.textGiamTru : <any>null;
        data["baoHiemHanhKhach"] = this.baoHiemHanhKhach !== undefined ? this.baoHiemHanhKhach : <any>null;
        if (Array.isArray(this.nhanVienLoaiVes)) {
            data["nhanVienLoaiVes"] = [];
            for (let item of this.nhanVienLoaiVes)
                data["nhanVienLoaiVes"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface ILoaiVe extends IAuditableEntity {
    loaiVeId: number;
    tenLoaiVe?: string | null;
    tenHienThi?: string | null;
    giaTien: number;
    giaTruocThue?: number | null;
    ngayHieuLuc?: Date | null;
    ngayHetHanHieuLuc?: Date | null;
    soLanSuDung?: number | null;
    isSuDungTrongNgay: boolean;
    gioKetThucTrongNgay?: string | null;
    soNgayCoTheSD?: number | null;
    chiTietDichVu?: string | null;
    ghiChu?: string | null;
    isActive: boolean;
    isUseImage: boolean;
    phanLoaiVe: EnumCauHinhVe;
    nhomDichVuId?: number | null;
    nhomDichVu?: NhomDichVu | null;
    mauVeId: number;
    mauVe?: MauVe | null;
    ves?: Ve[] | null;
    loaiVeDichVus?: LoaiVeDichVu[] | null;
    tenantId?: number | null;
    mauSo?: string | null;
    kyHieu?: string | null;
    vat?: number | null;
    orderBy?: number | null;
    loaiTienTe: EnumLoaiTienTe;
    isGiamTru: boolean;
    maGiamTru?: string | null;
    phanTramGiamTru?: number | null;
    soTienGiamTru?: number | null;
    textGiamTru?: string | null;
    baoHiemHanhKhach?: number | null;
    nhanVienLoaiVes?: NhanVienLoaiVe[] | null;
}

export enum EnumCauHinhVe {
    VeThuong = "VeThuong",
    VeOTo = "VeOTo",
    VeXeMay = "VeXeMay",
    VeXeDien = "VeXeDien",
    VeGhiChu = "VeGhiChu",
    VeXeKhach = "VeXeKhach",
    VeKhuyenMai = "VeKhuyenMai",
    VeMoRong = "VeMoRong"
}

export class NhomDichVu implements INhomDichVu {
    nhomDichVuId!: number;
    tenNhomDichVu?: string | null;
    tenantId?: number | null;
    orderBy?: number | null;

    constructor(data?: INhomDichVu) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nhomDichVuId = _data["nhomDichVuId"] !== undefined ? _data["nhomDichVuId"] : <any>null;
            this.tenNhomDichVu = _data["tenNhomDichVu"] !== undefined ? _data["tenNhomDichVu"] : <any>null;
            this.tenantId = _data["tenantId"] !== undefined ? _data["tenantId"] : <any>null;
            this.orderBy = _data["orderBy"] !== undefined ? _data["orderBy"] : <any>null;
        }
    }

    static fromJS(data: any): NhomDichVu {
        data = typeof data === 'object' ? data : {};
        let result = new NhomDichVu();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nhomDichVuId"] = this.nhomDichVuId !== undefined ? this.nhomDichVuId : <any>null;
        data["tenNhomDichVu"] = this.tenNhomDichVu !== undefined ? this.tenNhomDichVu : <any>null;
        data["tenantId"] = this.tenantId !== undefined ? this.tenantId : <any>null;
        data["orderBy"] = this.orderBy !== undefined ? this.orderBy : <any>null;
        return data;
    }
}

export interface INhomDichVu {
    nhomDichVuId: number;
    tenNhomDichVu?: string | null;
    tenantId?: number | null;
    orderBy?: number | null;
}

export class MauVe extends AuditableEntity implements IMauVe {
    mauVeId!: number;
    tenMauVe?: string | null;
    duongDan?: string | null;
    noiDungMau?: string | null;
    mauVeMobile?: string | null;
    isSunmiPos!: boolean;

    constructor(data?: IMauVe) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.mauVeId = _data["mauVeId"] !== undefined ? _data["mauVeId"] : <any>null;
            this.tenMauVe = _data["tenMauVe"] !== undefined ? _data["tenMauVe"] : <any>null;
            this.duongDan = _data["duongDan"] !== undefined ? _data["duongDan"] : <any>null;
            this.noiDungMau = _data["noiDungMau"] !== undefined ? _data["noiDungMau"] : <any>null;
            this.mauVeMobile = _data["mauVeMobile"] !== undefined ? _data["mauVeMobile"] : <any>null;
            this.isSunmiPos = _data["isSunmiPos"] !== undefined ? _data["isSunmiPos"] : <any>null;
        }
    }

    static override fromJS(data: any): MauVe {
        data = typeof data === 'object' ? data : {};
        let result = new MauVe();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mauVeId"] = this.mauVeId !== undefined ? this.mauVeId : <any>null;
        data["tenMauVe"] = this.tenMauVe !== undefined ? this.tenMauVe : <any>null;
        data["duongDan"] = this.duongDan !== undefined ? this.duongDan : <any>null;
        data["noiDungMau"] = this.noiDungMau !== undefined ? this.noiDungMau : <any>null;
        data["mauVeMobile"] = this.mauVeMobile !== undefined ? this.mauVeMobile : <any>null;
        data["isSunmiPos"] = this.isSunmiPos !== undefined ? this.isSunmiPos : <any>null;
        super.toJSON(data);
        return data;
    }
}

export interface IMauVe extends IAuditableEntity {
    mauVeId: number;
    tenMauVe?: string | null;
    duongDan?: string | null;
    noiDungMau?: string | null;
    mauVeMobile?: string | null;
    isSunmiPos: boolean;
}

export class Ve extends AuditableEntity implements IVe {
    veId!: string;
    maVe?: string | null;
    thoiGianPhatHanh!: Date;
    thoiGianHetHan!: Date;
    thoiGianSuDung?: Date | null;
    thoiGianHuyVe?: Date | null;
    trangThai!: EnumTrangThaiVe;
    stringTrangThai?: string | null;
    daInVe!: boolean;
    soLanIn!: number;
    base64Image?: string | null;
    nhanVienCaLamViecId?: string | null;
    hopDongVeId!: string;
    hopDongVe?: HopDongVe | null;
    loaiVeId!: number;
    loaiVe?: LoaiVe | null;
    nhanVienId!: number;
    nhanVien?: NhanVien | null;
    maKiemSoat?: string | null;
    maKSLoaiVe?: string | null;
    tenLoaiVe?: string | null;
    giaTruocThue?: number | null;
    giaSauThue?: number | null;
    giaThue?: number | null;
    vat?: number | null;
    loaiTienTe!: EnumLoaiTienTe;
    groupId?: string | null;
    bienSoXe?: string | null;
    gheNgoi?: string | null;
    thoiGianXuatBen?: Date | null;
    tenHanhKhach?: string | null;
    soDienThoaiHK?: string | null;
    tenTaiXe?: string | null;
    emailKhachHang?: string | null;
    maTraCuuHoaDon?: string | null;

    constructor(data?: IVe) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.veId = _data["veId"] !== undefined ? _data["veId"] : <any>null;
            this.maVe = _data["maVe"] !== undefined ? _data["maVe"] : <any>null;
            this.thoiGianPhatHanh = _data["thoiGianPhatHanh"] ? new Date(_data["thoiGianPhatHanh"].toString()) : <any>null;
            this.thoiGianHetHan = _data["thoiGianHetHan"] ? new Date(_data["thoiGianHetHan"].toString()) : <any>null;
            this.thoiGianSuDung = _data["thoiGianSuDung"] ? new Date(_data["thoiGianSuDung"].toString()) : <any>null;
            this.thoiGianHuyVe = _data["thoiGianHuyVe"] ? new Date(_data["thoiGianHuyVe"].toString()) : <any>null;
            this.trangThai = _data["trangThai"] !== undefined ? _data["trangThai"] : <any>null;
            this.stringTrangThai = _data["stringTrangThai"] !== undefined ? _data["stringTrangThai"] : <any>null;
            this.daInVe = _data["daInVe"] !== undefined ? _data["daInVe"] : <any>null;
            this.soLanIn = _data["soLanIn"] !== undefined ? _data["soLanIn"] : <any>null;
            this.base64Image = _data["base64Image"] !== undefined ? _data["base64Image"] : <any>null;
            this.nhanVienCaLamViecId = _data["nhanVienCaLamViecId"] !== undefined ? _data["nhanVienCaLamViecId"] : <any>null;
            this.hopDongVeId = _data["hopDongVeId"] !== undefined ? _data["hopDongVeId"] : <any>null;
            this.hopDongVe = _data["hopDongVe"] ? HopDongVe.fromJS(_data["hopDongVe"]) : <any>null;
            this.loaiVeId = _data["loaiVeId"] !== undefined ? _data["loaiVeId"] : <any>null;
            this.loaiVe = _data["loaiVe"] ? LoaiVe.fromJS(_data["loaiVe"]) : <any>null;
            this.nhanVienId = _data["nhanVienId"] !== undefined ? _data["nhanVienId"] : <any>null;
            this.nhanVien = _data["nhanVien"] ? NhanVien.fromJS(_data["nhanVien"]) : <any>null;
            this.maKiemSoat = _data["maKiemSoat"] !== undefined ? _data["maKiemSoat"] : <any>null;
            this.maKSLoaiVe = _data["maKSLoaiVe"] !== undefined ? _data["maKSLoaiVe"] : <any>null;
            this.tenLoaiVe = _data["tenLoaiVe"] !== undefined ? _data["tenLoaiVe"] : <any>null;
            this.giaTruocThue = _data["giaTruocThue"] !== undefined ? _data["giaTruocThue"] : <any>null;
            this.giaSauThue = _data["giaSauThue"] !== undefined ? _data["giaSauThue"] : <any>null;
            this.giaThue = _data["giaThue"] !== undefined ? _data["giaThue"] : <any>null;
            this.vat = _data["vat"] !== undefined ? _data["vat"] : <any>null;
            this.loaiTienTe = _data["loaiTienTe"] !== undefined ? _data["loaiTienTe"] : <any>null;
            this.groupId = _data["groupId"] !== undefined ? _data["groupId"] : <any>null;
            this.bienSoXe = _data["bienSoXe"] !== undefined ? _data["bienSoXe"] : <any>null;
            this.gheNgoi = _data["gheNgoi"] !== undefined ? _data["gheNgoi"] : <any>null;
            this.thoiGianXuatBen = _data["thoiGianXuatBen"] ? new Date(_data["thoiGianXuatBen"].toString()) : <any>null;
            this.tenHanhKhach = _data["tenHanhKhach"] !== undefined ? _data["tenHanhKhach"] : <any>null;
            this.soDienThoaiHK = _data["soDienThoaiHK"] !== undefined ? _data["soDienThoaiHK"] : <any>null;
            this.tenTaiXe = _data["tenTaiXe"] !== undefined ? _data["tenTaiXe"] : <any>null;
            this.emailKhachHang = _data["emailKhachHang"] !== undefined ? _data["emailKhachHang"] : <any>null;
            this.maTraCuuHoaDon = _data["maTraCuuHoaDon"] !== undefined ? _data["maTraCuuHoaDon"] : <any>null;
        }
    }

    static override fromJS(data: any): Ve {
        data = typeof data === 'object' ? data : {};
        let result = new Ve();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["veId"] = this.veId !== undefined ? this.veId : <any>null;
        data["maVe"] = this.maVe !== undefined ? this.maVe : <any>null;
        data["thoiGianPhatHanh"] = this.thoiGianPhatHanh ? this.thoiGianPhatHanh.toISOString() : <any>null;
        data["thoiGianHetHan"] = this.thoiGianHetHan ? this.thoiGianHetHan.toISOString() : <any>null;
        data["thoiGianSuDung"] = this.thoiGianSuDung ? this.thoiGianSuDung.toISOString() : <any>null;
        data["thoiGianHuyVe"] = this.thoiGianHuyVe ? this.thoiGianHuyVe.toISOString() : <any>null;
        data["trangThai"] = this.trangThai !== undefined ? this.trangThai : <any>null;
        data["stringTrangThai"] = this.stringTrangThai !== undefined ? this.stringTrangThai : <any>null;
        data["daInVe"] = this.daInVe !== undefined ? this.daInVe : <any>null;
        data["soLanIn"] = this.soLanIn !== undefined ? this.soLanIn : <any>null;
        data["base64Image"] = this.base64Image !== undefined ? this.base64Image : <any>null;
        data["nhanVienCaLamViecId"] = this.nhanVienCaLamViecId !== undefined ? this.nhanVienCaLamViecId : <any>null;
        data["hopDongVeId"] = this.hopDongVeId !== undefined ? this.hopDongVeId : <any>null;
        data["hopDongVe"] = this.hopDongVe ? this.hopDongVe.toJSON() : <any>null;
        data["loaiVeId"] = this.loaiVeId !== undefined ? this.loaiVeId : <any>null;
        data["loaiVe"] = this.loaiVe ? this.loaiVe.toJSON() : <any>null;
        data["nhanVienId"] = this.nhanVienId !== undefined ? this.nhanVienId : <any>null;
        data["nhanVien"] = this.nhanVien ? this.nhanVien.toJSON() : <any>null;
        data["maKiemSoat"] = this.maKiemSoat !== undefined ? this.maKiemSoat : <any>null;
        data["maKSLoaiVe"] = this.maKSLoaiVe !== undefined ? this.maKSLoaiVe : <any>null;
        data["tenLoaiVe"] = this.tenLoaiVe !== undefined ? this.tenLoaiVe : <any>null;
        data["giaTruocThue"] = this.giaTruocThue !== undefined ? this.giaTruocThue : <any>null;
        data["giaSauThue"] = this.giaSauThue !== undefined ? this.giaSauThue : <any>null;
        data["giaThue"] = this.giaThue !== undefined ? this.giaThue : <any>null;
        data["vat"] = this.vat !== undefined ? this.vat : <any>null;
        data["loaiTienTe"] = this.loaiTienTe !== undefined ? this.loaiTienTe : <any>null;
        data["groupId"] = this.groupId !== undefined ? this.groupId : <any>null;
        data["bienSoXe"] = this.bienSoXe !== undefined ? this.bienSoXe : <any>null;
        data["gheNgoi"] = this.gheNgoi !== undefined ? this.gheNgoi : <any>null;
        data["thoiGianXuatBen"] = this.thoiGianXuatBen ? this.thoiGianXuatBen.toISOString() : <any>null;
        data["tenHanhKhach"] = this.tenHanhKhach !== undefined ? this.tenHanhKhach : <any>null;
        data["soDienThoaiHK"] = this.soDienThoaiHK !== undefined ? this.soDienThoaiHK : <any>null;
        data["tenTaiXe"] = this.tenTaiXe !== undefined ? this.tenTaiXe : <any>null;
        data["emailKhachHang"] = this.emailKhachHang !== undefined ? this.emailKhachHang : <any>null;
        data["maTraCuuHoaDon"] = this.maTraCuuHoaDon !== undefined ? this.maTraCuuHoaDon : <any>null;
        super.toJSON(data);
        return data;
    }
}

export interface IVe extends IAuditableEntity {
    veId: string;
    maVe?: string | null;
    thoiGianPhatHanh: Date;
    thoiGianHetHan: Date;
    thoiGianSuDung?: Date | null;
    thoiGianHuyVe?: Date | null;
    trangThai: EnumTrangThaiVe;
    stringTrangThai?: string | null;
    daInVe: boolean;
    soLanIn: number;
    base64Image?: string | null;
    nhanVienCaLamViecId?: string | null;
    hopDongVeId: string;
    hopDongVe?: HopDongVe | null;
    loaiVeId: number;
    loaiVe?: LoaiVe | null;
    nhanVienId: number;
    nhanVien?: NhanVien | null;
    maKiemSoat?: string | null;
    maKSLoaiVe?: string | null;
    tenLoaiVe?: string | null;
    giaTruocThue?: number | null;
    giaSauThue?: number | null;
    giaThue?: number | null;
    vat?: number | null;
    loaiTienTe: EnumLoaiTienTe;
    groupId?: string | null;
    bienSoXe?: string | null;
    gheNgoi?: string | null;
    thoiGianXuatBen?: Date | null;
    tenHanhKhach?: string | null;
    soDienThoaiHK?: string | null;
    tenTaiXe?: string | null;
    emailKhachHang?: string | null;
    maTraCuuHoaDon?: string | null;
}

export enum EnumTrangThaiVe {
    ChuaThanhToan = "ChuaThanhToan",
    DaThanhToan = "DaThanhToan",
    Huy = "Huy",
    DaSuDung = "DaSuDung",
}

export class HopDongVe extends AuditableEntity implements IHopDongVe {
    hopDongVeId!: string;
    chietKhau?: number | null;
    sdtLienHe?: string | null;
    tenNguoiDat?: string | null;
    thoiGianDatVe!: Date;
    thoiGianHieuLuc!: Date;
    tenDonVi?: string | null;
    mst?: string | null;
    diaChi?: string | null;
    stk?: string | null;
    hinhThucThanhToan?: EnumHinhThucThanhToan | null;
    nganHang?: string | null;
    trangThai!: EnumTrangThaiVeDoan;
    chiTiet?: string | null;
    nhanVienId!: number;
    tongTienChuaCK?: number | null;
    datCoc?: number | null;
    maHopDong?: string | null;
    loaiHopDong!: EnumLoaiHopDong;
    cccd?: string | null;
    email?: string | null;
    isGiamTru!: boolean;
    maGiamTru?: string | null;
    phanTramGiamTru?: number | null;
    soTienGiamTru?: number | null;
    textGiamTru?: string | null;
    ghiChu?: string | null;
    ves?: Ve[] | null;

    constructor(data?: IHopDongVe) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.hopDongVeId = _data["hopDongVeId"] !== undefined ? _data["hopDongVeId"] : <any>null;
            this.chietKhau = _data["chietKhau"] !== undefined ? _data["chietKhau"] : <any>null;
            this.sdtLienHe = _data["sdtLienHe"] !== undefined ? _data["sdtLienHe"] : <any>null;
            this.tenNguoiDat = _data["tenNguoiDat"] !== undefined ? _data["tenNguoiDat"] : <any>null;
            this.thoiGianDatVe = _data["thoiGianDatVe"] ? new Date(_data["thoiGianDatVe"].toString()) : <any>null;
            this.thoiGianHieuLuc = _data["thoiGianHieuLuc"] ? new Date(_data["thoiGianHieuLuc"].toString()) : <any>null;
            this.tenDonVi = _data["tenDonVi"] !== undefined ? _data["tenDonVi"] : <any>null;
            this.mst = _data["mst"] !== undefined ? _data["mst"] : <any>null;
            this.diaChi = _data["diaChi"] !== undefined ? _data["diaChi"] : <any>null;
            this.stk = _data["stk"] !== undefined ? _data["stk"] : <any>null;
            this.hinhThucThanhToan = _data["hinhThucThanhToan"] !== undefined ? _data["hinhThucThanhToan"] : <any>null;
            this.nganHang = _data["nganHang"] !== undefined ? _data["nganHang"] : <any>null;
            this.trangThai = _data["trangThai"] !== undefined ? _data["trangThai"] : <any>null;
            this.chiTiet = _data["chiTiet"] !== undefined ? _data["chiTiet"] : <any>null;
            this.nhanVienId = _data["nhanVienId"] !== undefined ? _data["nhanVienId"] : <any>null;
            this.tongTienChuaCK = _data["tongTienChuaCK"] !== undefined ? _data["tongTienChuaCK"] : <any>null;
            this.datCoc = _data["datCoc"] !== undefined ? _data["datCoc"] : <any>null;
            this.maHopDong = _data["maHopDong"] !== undefined ? _data["maHopDong"] : <any>null;
            this.loaiHopDong = _data["loaiHopDong"] !== undefined ? _data["loaiHopDong"] : <any>null;
            this.cccd = _data["cccd"] !== undefined ? _data["cccd"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.isGiamTru = _data["isGiamTru"] !== undefined ? _data["isGiamTru"] : <any>null;
            this.maGiamTru = _data["maGiamTru"] !== undefined ? _data["maGiamTru"] : <any>null;
            this.phanTramGiamTru = _data["phanTramGiamTru"] !== undefined ? _data["phanTramGiamTru"] : <any>null;
            this.soTienGiamTru = _data["soTienGiamTru"] !== undefined ? _data["soTienGiamTru"] : <any>null;
            this.textGiamTru = _data["textGiamTru"] !== undefined ? _data["textGiamTru"] : <any>null;
            this.ghiChu = _data["ghiChu"] !== undefined ? _data["ghiChu"] : <any>null;
            if (Array.isArray(_data["ves"])) {
                this.ves = [] as any;
                for (let item of _data["ves"])
                    this.ves!.push(Ve.fromJS(item));
            }
            else {
                this.ves = <any>null;
            }
        }
    }

    static override fromJS(data: any): HopDongVe {
        data = typeof data === 'object' ? data : {};
        let result = new HopDongVe();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hopDongVeId"] = this.hopDongVeId !== undefined ? this.hopDongVeId : <any>null;
        data["chietKhau"] = this.chietKhau !== undefined ? this.chietKhau : <any>null;
        data["sdtLienHe"] = this.sdtLienHe !== undefined ? this.sdtLienHe : <any>null;
        data["tenNguoiDat"] = this.tenNguoiDat !== undefined ? this.tenNguoiDat : <any>null;
        data["thoiGianDatVe"] = this.thoiGianDatVe ? this.thoiGianDatVe.toISOString() : <any>null;
        data["thoiGianHieuLuc"] = this.thoiGianHieuLuc ? this.thoiGianHieuLuc.toISOString() : <any>null;
        data["tenDonVi"] = this.tenDonVi !== undefined ? this.tenDonVi : <any>null;
        data["mst"] = this.mst !== undefined ? this.mst : <any>null;
        data["diaChi"] = this.diaChi !== undefined ? this.diaChi : <any>null;
        data["stk"] = this.stk !== undefined ? this.stk : <any>null;
        data["hinhThucThanhToan"] = this.hinhThucThanhToan !== undefined ? this.hinhThucThanhToan : <any>null;
        data["nganHang"] = this.nganHang !== undefined ? this.nganHang : <any>null;
        data["trangThai"] = this.trangThai !== undefined ? this.trangThai : <any>null;
        data["chiTiet"] = this.chiTiet !== undefined ? this.chiTiet : <any>null;
        data["nhanVienId"] = this.nhanVienId !== undefined ? this.nhanVienId : <any>null;
        data["tongTienChuaCK"] = this.tongTienChuaCK !== undefined ? this.tongTienChuaCK : <any>null;
        data["datCoc"] = this.datCoc !== undefined ? this.datCoc : <any>null;
        data["maHopDong"] = this.maHopDong !== undefined ? this.maHopDong : <any>null;
        data["loaiHopDong"] = this.loaiHopDong !== undefined ? this.loaiHopDong : <any>null;
        data["cccd"] = this.cccd !== undefined ? this.cccd : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["isGiamTru"] = this.isGiamTru !== undefined ? this.isGiamTru : <any>null;
        data["maGiamTru"] = this.maGiamTru !== undefined ? this.maGiamTru : <any>null;
        data["phanTramGiamTru"] = this.phanTramGiamTru !== undefined ? this.phanTramGiamTru : <any>null;
        data["soTienGiamTru"] = this.soTienGiamTru !== undefined ? this.soTienGiamTru : <any>null;
        data["textGiamTru"] = this.textGiamTru !== undefined ? this.textGiamTru : <any>null;
        data["ghiChu"] = this.ghiChu !== undefined ? this.ghiChu : <any>null;
        if (Array.isArray(this.ves)) {
            data["ves"] = [];
            for (let item of this.ves)
                data["ves"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IHopDongVe extends IAuditableEntity {
    hopDongVeId: string;
    chietKhau?: number | null;
    sdtLienHe?: string | null;
    tenNguoiDat?: string | null;
    thoiGianDatVe: Date;
    thoiGianHieuLuc: Date;
    tenDonVi?: string | null;
    mst?: string | null;
    diaChi?: string | null;
    stk?: string | null;
    hinhThucThanhToan?: EnumHinhThucThanhToan | null;
    nganHang?: string | null;
    trangThai: EnumTrangThaiVeDoan;
    chiTiet?: string | null;
    nhanVienId: number;
    tongTienChuaCK?: number | null;
    datCoc?: number | null;
    maHopDong?: string | null;
    loaiHopDong: EnumLoaiHopDong;
    cccd?: string | null;
    email?: string | null;
    isGiamTru: boolean;
    maGiamTru?: string | null;
    phanTramGiamTru?: number | null;
    soTienGiamTru?: number | null;
    textGiamTru?: string | null;
    ghiChu?: string | null;
    ves?: Ve[] | null;
}

export enum EnumHinhThucThanhToan {
    TrucTiep = "TrucTiep",
    ChuyenKhoan = "ChuyenKhoan",
    NganHang = "NganHang",
    ViDienTu = "ViDienTu",
}

export enum EnumTrangThaiVeDoan {
    ChuaThanhToan = "ChuaThanhToan",
    DaDatCoc = "DaDatCoc",
    DaThanhToan = "DaThanhToan",
    DaSuDung = "DaSuDung",
    HuyHopDong = "HuyHopDong",
}

export enum EnumLoaiHopDong {
    KhachLe = "KhachLe",
    KhachDatTruoc = "KhachDatTruoc",
}

export class NhanVien extends AuditableEntity implements INhanVien {
    nhanVienId!: number;
    tenNhanVien?: string | null;
    ngaySinh?: Date | null;
    cccd?: string | null;
    diaChi?: string | null;
    userId?: string | null;
    isNotSeller!: boolean;
    isNotCancelTicket!: boolean;
    isNotRePrintTicket!: boolean;
    nhanVienLoaiVes?: NhanVienLoaiVe[] | null;

    constructor(data?: INhanVien) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.nhanVienId = _data["nhanVienId"] !== undefined ? _data["nhanVienId"] : <any>null;
            this.tenNhanVien = _data["tenNhanVien"] !== undefined ? _data["tenNhanVien"] : <any>null;
            this.ngaySinh = _data["ngaySinh"] ? new Date(_data["ngaySinh"].toString()) : <any>null;
            this.cccd = _data["cccd"] !== undefined ? _data["cccd"] : <any>null;
            this.diaChi = _data["diaChi"] !== undefined ? _data["diaChi"] : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.isNotSeller = _data["isNotSeller"] !== undefined ? _data["isNotSeller"] : <any>null;
            this.isNotCancelTicket = _data["isNotCancelTicket"] !== undefined ? _data["isNotCancelTicket"] : <any>null;
            this.isNotRePrintTicket = _data["isNotRePrintTicket"] !== undefined ? _data["isNotRePrintTicket"] : <any>null;
            if (Array.isArray(_data["nhanVienLoaiVes"])) {
                this.nhanVienLoaiVes = [] as any;
                for (let item of _data["nhanVienLoaiVes"])
                    this.nhanVienLoaiVes!.push(NhanVienLoaiVe.fromJS(item));
            }
            else {
                this.nhanVienLoaiVes = <any>null;
            }
        }
    }

    static override fromJS(data: any): NhanVien {
        data = typeof data === 'object' ? data : {};
        let result = new NhanVien();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nhanVienId"] = this.nhanVienId !== undefined ? this.nhanVienId : <any>null;
        data["tenNhanVien"] = this.tenNhanVien !== undefined ? this.tenNhanVien : <any>null;
        data["ngaySinh"] = this.ngaySinh ? this.ngaySinh.toISOString() : <any>null;
        data["cccd"] = this.cccd !== undefined ? this.cccd : <any>null;
        data["diaChi"] = this.diaChi !== undefined ? this.diaChi : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["isNotSeller"] = this.isNotSeller !== undefined ? this.isNotSeller : <any>null;
        data["isNotCancelTicket"] = this.isNotCancelTicket !== undefined ? this.isNotCancelTicket : <any>null;
        data["isNotRePrintTicket"] = this.isNotRePrintTicket !== undefined ? this.isNotRePrintTicket : <any>null;
        if (Array.isArray(this.nhanVienLoaiVes)) {
            data["nhanVienLoaiVes"] = [];
            for (let item of this.nhanVienLoaiVes)
                data["nhanVienLoaiVes"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface INhanVien extends IAuditableEntity {
    nhanVienId: number;
    tenNhanVien?: string | null;
    ngaySinh?: Date | null;
    cccd?: string | null;
    diaChi?: string | null;
    userId?: string | null;
    isNotSeller: boolean;
    isNotCancelTicket: boolean;
    isNotRePrintTicket: boolean;
    nhanVienLoaiVes?: NhanVienLoaiVe[] | null;
}

export class NhanVienLoaiVe extends AuditableEntity implements INhanVienLoaiVe {
    nhanVienLoaiVeId!: string;
    nhanVienId!: number;
    nhanVien?: NhanVien | null;
    loaiVeId?: number | null;
    loaiVe?: LoaiVe | null;
    isActive!: boolean;

    constructor(data?: INhanVienLoaiVe) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.nhanVienLoaiVeId = _data["nhanVienLoaiVeId"] !== undefined ? _data["nhanVienLoaiVeId"] : <any>null;
            this.nhanVienId = _data["nhanVienId"] !== undefined ? _data["nhanVienId"] : <any>null;
            this.nhanVien = _data["nhanVien"] ? NhanVien.fromJS(_data["nhanVien"]) : <any>null;
            this.loaiVeId = _data["loaiVeId"] !== undefined ? _data["loaiVeId"] : <any>null;
            this.loaiVe = _data["loaiVe"] ? LoaiVe.fromJS(_data["loaiVe"]) : <any>null;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
        }
    }

    static override fromJS(data: any): NhanVienLoaiVe {
        data = typeof data === 'object' ? data : {};
        let result = new NhanVienLoaiVe();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nhanVienLoaiVeId"] = this.nhanVienLoaiVeId !== undefined ? this.nhanVienLoaiVeId : <any>null;
        data["nhanVienId"] = this.nhanVienId !== undefined ? this.nhanVienId : <any>null;
        data["nhanVien"] = this.nhanVien ? this.nhanVien.toJSON() : <any>null;
        data["loaiVeId"] = this.loaiVeId !== undefined ? this.loaiVeId : <any>null;
        data["loaiVe"] = this.loaiVe ? this.loaiVe.toJSON() : <any>null;
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        super.toJSON(data);
        return data;
    }
}

export interface INhanVienLoaiVe extends IAuditableEntity {
    nhanVienLoaiVeId: string;
    nhanVienId: number;
    nhanVien?: NhanVien | null;
    loaiVeId?: number | null;
    loaiVe?: LoaiVe | null;
    isActive: boolean;
}

export enum EnumLoaiTienTe {
    VND = "VND",
    USD = "USD",
    NDT = "NDT",
}

export class LoaiVeDichVu implements ILoaiVeDichVu {
    loaiVeDichVuId!: number;
    dichVuId!: number;
    dichVu?: DichVu | null;
    loaiVeId!: number;
    loaiVe?: LoaiVe | null;
    tenantId?: number | null;

    constructor(data?: ILoaiVeDichVu) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loaiVeDichVuId = _data["loaiVeDichVuId"] !== undefined ? _data["loaiVeDichVuId"] : <any>null;
            this.dichVuId = _data["dichVuId"] !== undefined ? _data["dichVuId"] : <any>null;
            this.dichVu = _data["dichVu"] ? DichVu.fromJS(_data["dichVu"]) : <any>null;
            this.loaiVeId = _data["loaiVeId"] !== undefined ? _data["loaiVeId"] : <any>null;
            this.loaiVe = _data["loaiVe"] ? LoaiVe.fromJS(_data["loaiVe"]) : <any>null;
            this.tenantId = _data["tenantId"] !== undefined ? _data["tenantId"] : <any>null;
        }
    }

    static fromJS(data: any): LoaiVeDichVu {
        data = typeof data === 'object' ? data : {};
        let result = new LoaiVeDichVu();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loaiVeDichVuId"] = this.loaiVeDichVuId !== undefined ? this.loaiVeDichVuId : <any>null;
        data["dichVuId"] = this.dichVuId !== undefined ? this.dichVuId : <any>null;
        data["dichVu"] = this.dichVu ? this.dichVu.toJSON() : <any>null;
        data["loaiVeId"] = this.loaiVeId !== undefined ? this.loaiVeId : <any>null;
        data["loaiVe"] = this.loaiVe ? this.loaiVe.toJSON() : <any>null;
        data["tenantId"] = this.tenantId !== undefined ? this.tenantId : <any>null;
        return data;
    }
}

export interface ILoaiVeDichVu {
    loaiVeDichVuId: number;
    dichVuId: number;
    dichVu?: DichVu | null;
    loaiVeId: number;
    loaiVe?: LoaiVe | null;
    tenantId?: number | null;
}

export class DichVu extends AuditableEntity implements IDichVu {
    dichVuId!: number;
    tenDichVu?: string | null;
    tenHienThi?: string | null;
    giaDichVu?: number | null;
    giaTruocThue?: number | null;
    chiTiet?: string | null;
    isActive!: boolean;
    ngayHetHan?: Date | null;
    loaiVeDichVus?: LoaiVeDichVu[] | null;
    mauSo?: string | null;
    kyHieu?: string | null;
    vat?: number | null;
    noSendInvoice!: boolean;
    loaiTienTe!: EnumLoaiTienTe;
    orderBy?: number | null;

    constructor(data?: IDichVu) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.dichVuId = _data["dichVuId"] !== undefined ? _data["dichVuId"] : <any>null;
            this.tenDichVu = _data["tenDichVu"] !== undefined ? _data["tenDichVu"] : <any>null;
            this.tenHienThi = _data["tenHienThi"] !== undefined ? _data["tenHienThi"] : <any>null;
            this.giaDichVu = _data["giaDichVu"] !== undefined ? _data["giaDichVu"] : <any>null;
            this.giaTruocThue = _data["giaTruocThue"] !== undefined ? _data["giaTruocThue"] : <any>null;
            this.chiTiet = _data["chiTiet"] !== undefined ? _data["chiTiet"] : <any>null;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
            this.ngayHetHan = _data["ngayHetHan"] ? new Date(_data["ngayHetHan"].toString()) : <any>null;
            if (Array.isArray(_data["loaiVeDichVus"])) {
                this.loaiVeDichVus = [] as any;
                for (let item of _data["loaiVeDichVus"])
                    this.loaiVeDichVus!.push(LoaiVeDichVu.fromJS(item));
            }
            else {
                this.loaiVeDichVus = <any>null;
            }
            this.mauSo = _data["mauSo"] !== undefined ? _data["mauSo"] : <any>null;
            this.kyHieu = _data["kyHieu"] !== undefined ? _data["kyHieu"] : <any>null;
            this.vat = _data["vat"] !== undefined ? _data["vat"] : <any>null;
            this.noSendInvoice = _data["noSendInvoice"] !== undefined ? _data["noSendInvoice"] : <any>null;
            this.loaiTienTe = _data["loaiTienTe"] !== undefined ? _data["loaiTienTe"] : <any>null;
            this.orderBy = _data["orderBy"] !== undefined ? _data["orderBy"] : <any>null;
        }
    }

    static override fromJS(data: any): DichVu {
        data = typeof data === 'object' ? data : {};
        let result = new DichVu();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dichVuId"] = this.dichVuId !== undefined ? this.dichVuId : <any>null;
        data["tenDichVu"] = this.tenDichVu !== undefined ? this.tenDichVu : <any>null;
        data["tenHienThi"] = this.tenHienThi !== undefined ? this.tenHienThi : <any>null;
        data["giaDichVu"] = this.giaDichVu !== undefined ? this.giaDichVu : <any>null;
        data["giaTruocThue"] = this.giaTruocThue !== undefined ? this.giaTruocThue : <any>null;
        data["chiTiet"] = this.chiTiet !== undefined ? this.chiTiet : <any>null;
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        data["ngayHetHan"] = this.ngayHetHan ? this.ngayHetHan.toISOString() : <any>null;
        if (Array.isArray(this.loaiVeDichVus)) {
            data["loaiVeDichVus"] = [];
            for (let item of this.loaiVeDichVus)
                data["loaiVeDichVus"].push(item.toJSON());
        }
        data["mauSo"] = this.mauSo !== undefined ? this.mauSo : <any>null;
        data["kyHieu"] = this.kyHieu !== undefined ? this.kyHieu : <any>null;
        data["vat"] = this.vat !== undefined ? this.vat : <any>null;
        data["noSendInvoice"] = this.noSendInvoice !== undefined ? this.noSendInvoice : <any>null;
        data["loaiTienTe"] = this.loaiTienTe !== undefined ? this.loaiTienTe : <any>null;
        data["orderBy"] = this.orderBy !== undefined ? this.orderBy : <any>null;
        super.toJSON(data);
        return data;
    }
}

export interface IDichVu extends IAuditableEntity {
    dichVuId: number;
    tenDichVu?: string | null;
    tenHienThi?: string | null;
    giaDichVu?: number | null;
    giaTruocThue?: number | null;
    chiTiet?: string | null;
    isActive: boolean;
    ngayHetHan?: Date | null;
    loaiVeDichVus?: LoaiVeDichVu[] | null;
    mauSo?: string | null;
    kyHieu?: string | null;
    vat?: number | null;
    noSendInvoice: boolean;
    loaiTienTe: EnumLoaiTienTe;
    orderBy?: number | null;
}

export class CauHinhHoaDon implements ICauHinhHoaDon {
    cauHinhHoaDonId!: number;
    tenCongTy?: string | null;
    maSoThue?: string | null;
    diaChi?: string | null;
    soTaiKhoan?: string | null;
    nganHang?: string | null;
    soDienThoai?: string | null;
    serviceName?: string | null;
    serviceUrl?: string | null;
    publishServiceUrl?: string | null;
    bussinessServiceUrl?: string | null;
    serviceUserName?: string | null;
    serviceUserPass?: string | null;
    accountAdmin?: string | null;
    passAdmin?: string | null;
    pattern?: string | null;
    serial?: string | null;
    vat?: number | null;
    convert?: string | null;
    tenantId?: number | null;
    jsonData?: string | null;
    isPublishInv!: boolean;
    portalHD?: string | null;
    loaiTienTe!: EnumLoaiTienTe;
    isGiamTru!: boolean;
    maGiamTru?: string | null;
    phanTramGiamTru?: number | null;
    soTienGiamTru?: number | null;
    textGiamTru?: string | null;

    constructor(data?: ICauHinhHoaDon) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cauHinhHoaDonId = _data["cauHinhHoaDonId"] !== undefined ? _data["cauHinhHoaDonId"] : <any>null;
            this.tenCongTy = _data["tenCongTy"] !== undefined ? _data["tenCongTy"] : <any>null;
            this.maSoThue = _data["maSoThue"] !== undefined ? _data["maSoThue"] : <any>null;
            this.diaChi = _data["diaChi"] !== undefined ? _data["diaChi"] : <any>null;
            this.soTaiKhoan = _data["soTaiKhoan"] !== undefined ? _data["soTaiKhoan"] : <any>null;
            this.nganHang = _data["nganHang"] !== undefined ? _data["nganHang"] : <any>null;
            this.soDienThoai = _data["soDienThoai"] !== undefined ? _data["soDienThoai"] : <any>null;
            this.serviceName = _data["serviceName"] !== undefined ? _data["serviceName"] : <any>null;
            this.serviceUrl = _data["serviceUrl"] !== undefined ? _data["serviceUrl"] : <any>null;
            this.publishServiceUrl = _data["publishServiceUrl"] !== undefined ? _data["publishServiceUrl"] : <any>null;
            this.bussinessServiceUrl = _data["bussinessServiceUrl"] !== undefined ? _data["bussinessServiceUrl"] : <any>null;
            this.serviceUserName = _data["serviceUserName"] !== undefined ? _data["serviceUserName"] : <any>null;
            this.serviceUserPass = _data["serviceUserPass"] !== undefined ? _data["serviceUserPass"] : <any>null;
            this.accountAdmin = _data["accountAdmin"] !== undefined ? _data["accountAdmin"] : <any>null;
            this.passAdmin = _data["passAdmin"] !== undefined ? _data["passAdmin"] : <any>null;
            this.pattern = _data["pattern"] !== undefined ? _data["pattern"] : <any>null;
            this.serial = _data["serial"] !== undefined ? _data["serial"] : <any>null;
            this.vat = _data["vat"] !== undefined ? _data["vat"] : <any>null;
            this.convert = _data["convert"] !== undefined ? _data["convert"] : <any>null;
            this.tenantId = _data["tenantId"] !== undefined ? _data["tenantId"] : <any>null;
            this.jsonData = _data["jsonData"] !== undefined ? _data["jsonData"] : <any>null;
            this.isPublishInv = _data["isPublishInv"] !== undefined ? _data["isPublishInv"] : <any>null;
            this.portalHD = _data["portalHD"] !== undefined ? _data["portalHD"] : <any>null;
            this.loaiTienTe = _data["loaiTienTe"] !== undefined ? _data["loaiTienTe"] : <any>null;
            this.isGiamTru = _data["isGiamTru"] !== undefined ? _data["isGiamTru"] : <any>null;
            this.maGiamTru = _data["maGiamTru"] !== undefined ? _data["maGiamTru"] : <any>null;
            this.phanTramGiamTru = _data["phanTramGiamTru"] !== undefined ? _data["phanTramGiamTru"] : <any>null;
            this.soTienGiamTru = _data["soTienGiamTru"] !== undefined ? _data["soTienGiamTru"] : <any>null;
            this.textGiamTru = _data["textGiamTru"] !== undefined ? _data["textGiamTru"] : <any>null;
        }
    }

    static fromJS(data: any): CauHinhHoaDon {
        data = typeof data === 'object' ? data : {};
        let result = new CauHinhHoaDon();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cauHinhHoaDonId"] = this.cauHinhHoaDonId !== undefined ? this.cauHinhHoaDonId : <any>null;
        data["tenCongTy"] = this.tenCongTy !== undefined ? this.tenCongTy : <any>null;
        data["maSoThue"] = this.maSoThue !== undefined ? this.maSoThue : <any>null;
        data["diaChi"] = this.diaChi !== undefined ? this.diaChi : <any>null;
        data["soTaiKhoan"] = this.soTaiKhoan !== undefined ? this.soTaiKhoan : <any>null;
        data["nganHang"] = this.nganHang !== undefined ? this.nganHang : <any>null;
        data["soDienThoai"] = this.soDienThoai !== undefined ? this.soDienThoai : <any>null;
        data["serviceName"] = this.serviceName !== undefined ? this.serviceName : <any>null;
        data["serviceUrl"] = this.serviceUrl !== undefined ? this.serviceUrl : <any>null;
        data["publishServiceUrl"] = this.publishServiceUrl !== undefined ? this.publishServiceUrl : <any>null;
        data["bussinessServiceUrl"] = this.bussinessServiceUrl !== undefined ? this.bussinessServiceUrl : <any>null;
        data["serviceUserName"] = this.serviceUserName !== undefined ? this.serviceUserName : <any>null;
        data["serviceUserPass"] = this.serviceUserPass !== undefined ? this.serviceUserPass : <any>null;
        data["accountAdmin"] = this.accountAdmin !== undefined ? this.accountAdmin : <any>null;
        data["passAdmin"] = this.passAdmin !== undefined ? this.passAdmin : <any>null;
        data["pattern"] = this.pattern !== undefined ? this.pattern : <any>null;
        data["serial"] = this.serial !== undefined ? this.serial : <any>null;
        data["vat"] = this.vat !== undefined ? this.vat : <any>null;
        data["convert"] = this.convert !== undefined ? this.convert : <any>null;
        data["tenantId"] = this.tenantId !== undefined ? this.tenantId : <any>null;
        data["jsonData"] = this.jsonData !== undefined ? this.jsonData : <any>null;
        data["isPublishInv"] = this.isPublishInv !== undefined ? this.isPublishInv : <any>null;
        data["portalHD"] = this.portalHD !== undefined ? this.portalHD : <any>null;
        data["loaiTienTe"] = this.loaiTienTe !== undefined ? this.loaiTienTe : <any>null;
        data["isGiamTru"] = this.isGiamTru !== undefined ? this.isGiamTru : <any>null;
        data["maGiamTru"] = this.maGiamTru !== undefined ? this.maGiamTru : <any>null;
        data["phanTramGiamTru"] = this.phanTramGiamTru !== undefined ? this.phanTramGiamTru : <any>null;
        data["soTienGiamTru"] = this.soTienGiamTru !== undefined ? this.soTienGiamTru : <any>null;
        data["textGiamTru"] = this.textGiamTru !== undefined ? this.textGiamTru : <any>null;
        return data;
    }
}

export interface ICauHinhHoaDon {
    cauHinhHoaDonId: number;
    tenCongTy?: string | null;
    maSoThue?: string | null;
    diaChi?: string | null;
    soTaiKhoan?: string | null;
    nganHang?: string | null;
    soDienThoai?: string | null;
    serviceName?: string | null;
    serviceUrl?: string | null;
    publishServiceUrl?: string | null;
    bussinessServiceUrl?: string | null;
    serviceUserName?: string | null;
    serviceUserPass?: string | null;
    accountAdmin?: string | null;
    passAdmin?: string | null;
    pattern?: string | null;
    serial?: string | null;
    vat?: number | null;
    convert?: string | null;
    tenantId?: number | null;
    jsonData?: string | null;
    isPublishInv: boolean;
    portalHD?: string | null;
    loaiTienTe: EnumLoaiTienTe;
    isGiamTru: boolean;
    maGiamTru?: string | null;
    phanTramGiamTru?: number | null;
    soTienGiamTru?: number | null;
    textGiamTru?: string | null;
}

export class NhanVienDto implements INhanVienDto {
    nhanVienId!: number;
    tenNhanVien?: string | null;
    ngaySinh?: Date | null;
    cccd?: string | null;
    diaChi?: string | null;
    userId?: string | null;
    tenDangNhap?: string | null;
    matKhau?: string | null;
    tenantId?: number | null;
    tenantGroupId?: number | null;
    portalGroupId?: number | null;
    isActive!: boolean;

    constructor(data?: INhanVienDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nhanVienId = _data["nhanVienId"] !== undefined ? _data["nhanVienId"] : <any>null;
            this.tenNhanVien = _data["tenNhanVien"] !== undefined ? _data["tenNhanVien"] : <any>null;
            this.ngaySinh = _data["ngaySinh"] ? new Date(_data["ngaySinh"].toString()) : <any>null;
            this.cccd = _data["cccd"] !== undefined ? _data["cccd"] : <any>null;
            this.diaChi = _data["diaChi"] !== undefined ? _data["diaChi"] : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.tenDangNhap = _data["tenDangNhap"] !== undefined ? _data["tenDangNhap"] : <any>null;
            this.matKhau = _data["matKhau"] !== undefined ? _data["matKhau"] : <any>null;
            this.tenantId = _data["tenantId"] !== undefined ? _data["tenantId"] : <any>null;
            this.tenantGroupId = _data["tenantGroupId"] !== undefined ? _data["tenantGroupId"] : <any>null;
            this.portalGroupId = _data["portalGroupId"] !== undefined ? _data["portalGroupId"] : <any>null;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
        }
    }

    static fromJS(data: any): NhanVienDto {
        data = typeof data === 'object' ? data : {};
        let result = new NhanVienDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nhanVienId"] = this.nhanVienId !== undefined ? this.nhanVienId : <any>null;
        data["tenNhanVien"] = this.tenNhanVien !== undefined ? this.tenNhanVien : <any>null;
        data["ngaySinh"] = this.ngaySinh ? this.ngaySinh.toISOString() : <any>null;
        data["cccd"] = this.cccd !== undefined ? this.cccd : <any>null;
        data["diaChi"] = this.diaChi !== undefined ? this.diaChi : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["tenDangNhap"] = this.tenDangNhap !== undefined ? this.tenDangNhap : <any>null;
        data["matKhau"] = this.matKhau !== undefined ? this.matKhau : <any>null;
        data["tenantId"] = this.tenantId !== undefined ? this.tenantId : <any>null;
        data["tenantGroupId"] = this.tenantGroupId !== undefined ? this.tenantGroupId : <any>null;
        data["portalGroupId"] = this.portalGroupId !== undefined ? this.portalGroupId : <any>null;
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        return data;
    }
}

export interface INhanVienDto {
    nhanVienId: number;
    tenNhanVien?: string | null;
    ngaySinh?: Date | null;
    cccd?: string | null;
    diaChi?: string | null;
    userId?: string | null;
    tenDangNhap?: string | null;
    matKhau?: string | null;
    tenantId?: number | null;
    tenantGroupId?: number | null;
    portalGroupId?: number | null;
    isActive: boolean;
}

export class TenantGroup implements ITenantGroup {
    tenantGroupId!: number;
    tenantGroupName?: string | null;

    constructor(data?: ITenantGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantGroupId = _data["tenantGroupId"] !== undefined ? _data["tenantGroupId"] : <any>null;
            this.tenantGroupName = _data["tenantGroupName"] !== undefined ? _data["tenantGroupName"] : <any>null;
        }
    }

    static fromJS(data: any): TenantGroup {
        data = typeof data === 'object' ? data : {};
        let result = new TenantGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantGroupId"] = this.tenantGroupId !== undefined ? this.tenantGroupId : <any>null;
        data["tenantGroupName"] = this.tenantGroupName !== undefined ? this.tenantGroupName : <any>null;
        return data;
    }
}

export interface ITenantGroup {
    tenantGroupId: number;
    tenantGroupName?: string | null;
}

export class ChangeStateTenantGroupRequest implements IChangeStateTenantGroupRequest {
    tenantId!: number;
    tenantGroupId!: number;

    constructor(data?: IChangeStateTenantGroupRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"] !== undefined ? _data["tenantId"] : <any>null;
            this.tenantGroupId = _data["tenantGroupId"] !== undefined ? _data["tenantGroupId"] : <any>null;
        }
    }

    static fromJS(data: any): ChangeStateTenantGroupRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeStateTenantGroupRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId !== undefined ? this.tenantId : <any>null;
        data["tenantGroupId"] = this.tenantGroupId !== undefined ? this.tenantGroupId : <any>null;
        return data;
    }
}

export interface IChangeStateTenantGroupRequest {
    tenantId: number;
    tenantGroupId: number;
}

export class PortalGroup implements IPortalGroup {
    portalGroupId!: number;
    portalName?: string | null;
    portalDescription?: string | null;
    createdBy?: string | null;
    createdDate!: Date;
    lastModifiedBy?: string | null;
    lastModified?: Date | null;

    constructor(data?: IPortalGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.portalGroupId = _data["portalGroupId"] !== undefined ? _data["portalGroupId"] : <any>null;
            this.portalName = _data["portalName"] !== undefined ? _data["portalName"] : <any>null;
            this.portalDescription = _data["portalDescription"] !== undefined ? _data["portalDescription"] : <any>null;
            this.createdBy = _data["createdBy"] !== undefined ? _data["createdBy"] : <any>null;
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>null;
            this.lastModifiedBy = _data["lastModifiedBy"] !== undefined ? _data["lastModifiedBy"] : <any>null;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): PortalGroup {
        data = typeof data === 'object' ? data : {};
        let result = new PortalGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["portalGroupId"] = this.portalGroupId !== undefined ? this.portalGroupId : <any>null;
        data["portalName"] = this.portalName !== undefined ? this.portalName : <any>null;
        data["portalDescription"] = this.portalDescription !== undefined ? this.portalDescription : <any>null;
        data["createdBy"] = this.createdBy !== undefined ? this.createdBy : <any>null;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>null;
        data["lastModifiedBy"] = this.lastModifiedBy !== undefined ? this.lastModifiedBy : <any>null;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>null;
        return data;
    }
}

export interface IPortalGroup {
    portalGroupId: number;
    portalName?: string | null;
    portalDescription?: string | null;
    createdBy?: string | null;
    createdDate: Date;
    lastModifiedBy?: string | null;
    lastModified?: Date | null;
}

export class ChangeStatePortalGroupRequest implements IChangeStatePortalGroupRequest {
    tenantId!: number;
    portalGroupId!: number;

    constructor(data?: IChangeStatePortalGroupRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"] !== undefined ? _data["tenantId"] : <any>null;
            this.portalGroupId = _data["portalGroupId"] !== undefined ? _data["portalGroupId"] : <any>null;
        }
    }

    static fromJS(data: any): ChangeStatePortalGroupRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeStatePortalGroupRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId !== undefined ? this.tenantId : <any>null;
        data["portalGroupId"] = this.portalGroupId !== undefined ? this.portalGroupId : <any>null;
        return data;
    }
}

export interface IChangeStatePortalGroupRequest {
    tenantId: number;
    portalGroupId: number;
}

export class PortalBaoCaoRequest implements IPortalBaoCaoRequest {
    tenDonVi?: string | null;
    tuNgay?: Date | null;
    denNgay?: Date | null;
    portalGroupId!: number;

    constructor(data?: IPortalBaoCaoRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenDonVi = _data["tenDonVi"] !== undefined ? _data["tenDonVi"] : <any>null;
            this.tuNgay = _data["tuNgay"] ? new Date(_data["tuNgay"].toString()) : <any>null;
            this.denNgay = _data["denNgay"] ? new Date(_data["denNgay"].toString()) : <any>null;
            this.portalGroupId = _data["portalGroupId"] !== undefined ? _data["portalGroupId"] : <any>null;
        }
    }

    static fromJS(data: any): PortalBaoCaoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PortalBaoCaoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenDonVi"] = this.tenDonVi !== undefined ? this.tenDonVi : <any>null;
        data["tuNgay"] = this.tuNgay ? this.tuNgay.toISOString() : <any>null;
        data["denNgay"] = this.denNgay ? this.denNgay.toISOString() : <any>null;
        data["portalGroupId"] = this.portalGroupId !== undefined ? this.portalGroupId : <any>null;
        return data;
    }
}

export interface IPortalBaoCaoRequest {
    tenDonVi?: string | null;
    tuNgay?: Date | null;
    denNgay?: Date | null;
    portalGroupId: number;
}

export class TaoVeRequest implements ITaoVeRequest {
    bienSoXe?: string | null;
    gheNgoi?: string | null;
    thoiGianXuatBen?: Date | null;
    tenHanhKhach?: string | null;
    soDienThoaiHK?: string | null;
    tenTaiXe?: string | null;
    emailKhachHang?: string | null;
    loaiVeId!: number;

    constructor(data?: ITaoVeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bienSoXe = _data["bienSoXe"] !== undefined ? _data["bienSoXe"] : <any>null;
            this.gheNgoi = _data["gheNgoi"] !== undefined ? _data["gheNgoi"] : <any>null;
            this.thoiGianXuatBen = _data["thoiGianXuatBen"] ? new Date(_data["thoiGianXuatBen"].toString()) : <any>null;
            this.tenHanhKhach = _data["tenHanhKhach"] !== undefined ? _data["tenHanhKhach"] : <any>null;
            this.soDienThoaiHK = _data["soDienThoaiHK"] !== undefined ? _data["soDienThoaiHK"] : <any>null;
            this.tenTaiXe = _data["tenTaiXe"] !== undefined ? _data["tenTaiXe"] : <any>null;
            this.emailKhachHang = _data["emailKhachHang"] !== undefined ? _data["emailKhachHang"] : <any>null;
            this.loaiVeId = _data["loaiVeId"] !== undefined ? _data["loaiVeId"] : <any>null;
        }
    }

    static fromJS(data: any): TaoVeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TaoVeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bienSoXe"] = this.bienSoXe !== undefined ? this.bienSoXe : <any>null;
        data["gheNgoi"] = this.gheNgoi !== undefined ? this.gheNgoi : <any>null;
        data["thoiGianXuatBen"] = this.thoiGianXuatBen ? this.thoiGianXuatBen.toISOString() : <any>null;
        data["tenHanhKhach"] = this.tenHanhKhach !== undefined ? this.tenHanhKhach : <any>null;
        data["soDienThoaiHK"] = this.soDienThoaiHK !== undefined ? this.soDienThoaiHK : <any>null;
        data["tenTaiXe"] = this.tenTaiXe !== undefined ? this.tenTaiXe : <any>null;
        data["emailKhachHang"] = this.emailKhachHang !== undefined ? this.emailKhachHang : <any>null;
        data["loaiVeId"] = this.loaiVeId !== undefined ? this.loaiVeId : <any>null;
        return data;
    }
}

export interface ITaoVeRequest {
    bienSoXe?: string | null;
    gheNgoi?: string | null;
    thoiGianXuatBen?: Date | null;
    tenHanhKhach?: string | null;
    soDienThoaiHK?: string | null;
    tenTaiXe?: string | null;
    emailKhachHang?: string | null;
    loaiVeId: number;
}

export class AuthenticateRequest implements IAuthenticateRequest {
    username!: string;
    password!: string;

    constructor(data?: IAuthenticateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): AuthenticateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export interface IAuthenticateRequest {
    username: string;
    password: string;
}

export class ApiResult implements IApiResult {
    status!: EnumStateApi;
    statusCode?: number | null;
    messages?: string | null;
    resultCode?: number | null;
    data?: any | null;

    constructor(data?: IApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.statusCode = _data["statusCode"] !== undefined ? _data["statusCode"] : <any>null;
            this.messages = _data["messages"] !== undefined ? _data["messages"] : <any>null;
            this.resultCode = _data["resultCode"] !== undefined ? _data["resultCode"] : <any>null;
            this.data = _data["data"] !== undefined ? _data["data"] : <any>null;
        }
    }

    static fromJS(data: any): ApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["statusCode"] = this.statusCode !== undefined ? this.statusCode : <any>null;
        data["messages"] = this.messages !== undefined ? this.messages : <any>null;
        data["resultCode"] = this.resultCode !== undefined ? this.resultCode : <any>null;
        data["data"] = this.data !== undefined ? this.data : <any>null;
        return data;
    }
}

export interface IApiResult {
    status: EnumStateApi;
    statusCode?: number | null;
    messages?: string | null;
    resultCode?: number | null;
    data?: any | null;
}

export enum EnumStateApi {
    Success = "Success",
    Error = "Error",
    Waring = "Waring",
}

export class CreateTicketMobileRequest implements ICreateTicketMobileRequest {
    bienSoXe?: string | null;
    gheNgoi?: string | null;
    thoiGianXuatBen?: Date | null;
    tenHanhKhach?: string | null;
    soDienThoaiHK?: string | null;
    tenTaiXe?: string | null;
    emailKhachHang?: string | null;
    ghiChu?: string | null;
    loaiVeId!: number;
    soLuongVe!: number;
    isInAnh!: boolean;

    constructor(data?: ICreateTicketMobileRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bienSoXe = _data["bienSoXe"] !== undefined ? _data["bienSoXe"] : <any>null;
            this.gheNgoi = _data["gheNgoi"] !== undefined ? _data["gheNgoi"] : <any>null;
            this.thoiGianXuatBen = _data["thoiGianXuatBen"] ? new Date(_data["thoiGianXuatBen"].toString()) : <any>null;
            this.tenHanhKhach = _data["tenHanhKhach"] !== undefined ? _data["tenHanhKhach"] : <any>null;
            this.soDienThoaiHK = _data["soDienThoaiHK"] !== undefined ? _data["soDienThoaiHK"] : <any>null;
            this.tenTaiXe = _data["tenTaiXe"] !== undefined ? _data["tenTaiXe"] : <any>null;
            this.emailKhachHang = _data["emailKhachHang"] !== undefined ? _data["emailKhachHang"] : <any>null;
            this.ghiChu = _data["ghiChu"] !== undefined ? _data["ghiChu"] : <any>null;
            this.loaiVeId = _data["loaiVeId"] !== undefined ? _data["loaiVeId"] : <any>null;
            this.soLuongVe = _data["soLuongVe"] !== undefined ? _data["soLuongVe"] : <any>null;
            this.isInAnh = _data["isInAnh"] !== undefined ? _data["isInAnh"] : <any>null;
        }
    }

    static fromJS(data: any): CreateTicketMobileRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTicketMobileRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bienSoXe"] = this.bienSoXe !== undefined ? this.bienSoXe : <any>null;
        data["gheNgoi"] = this.gheNgoi !== undefined ? this.gheNgoi : <any>null;
        data["thoiGianXuatBen"] = this.thoiGianXuatBen ? this.thoiGianXuatBen.toISOString() : <any>null;
        data["tenHanhKhach"] = this.tenHanhKhach !== undefined ? this.tenHanhKhach : <any>null;
        data["soDienThoaiHK"] = this.soDienThoaiHK !== undefined ? this.soDienThoaiHK : <any>null;
        data["tenTaiXe"] = this.tenTaiXe !== undefined ? this.tenTaiXe : <any>null;
        data["emailKhachHang"] = this.emailKhachHang !== undefined ? this.emailKhachHang : <any>null;
        data["ghiChu"] = this.ghiChu !== undefined ? this.ghiChu : <any>null;
        data["loaiVeId"] = this.loaiVeId !== undefined ? this.loaiVeId : <any>null;
        data["soLuongVe"] = this.soLuongVe !== undefined ? this.soLuongVe : <any>null;
        data["isInAnh"] = this.isInAnh !== undefined ? this.isInAnh : <any>null;
        return data;
    }
}

export interface ICreateTicketMobileRequest {
    bienSoXe?: string | null;
    gheNgoi?: string | null;
    thoiGianXuatBen?: Date | null;
    tenHanhKhach?: string | null;
    soDienThoaiHK?: string | null;
    tenTaiXe?: string | null;
    emailKhachHang?: string | null;
    ghiChu?: string | null;
    loaiVeId: number;
    soLuongVe: number;
    isInAnh: boolean;
}

export class ThongTinVeOffline implements IThongTinVeOffline {
    veId!: string;
    loaiVeId!: number;
    fkey?: string | null;
    soLuong!: number;
    bienSoXe?: string | null;
    gheNgoi?: string | null;
    thoiGianXuatBen?: Date | null;
    tenHanhKhach?: string | null;
    soDienThoaiHK?: string | null;
    tenTaiXe?: string | null;
    emailKhachHang?: string | null;

    constructor(data?: IThongTinVeOffline) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.veId = _data["veId"] !== undefined ? _data["veId"] : <any>null;
            this.loaiVeId = _data["loaiVeId"] !== undefined ? _data["loaiVeId"] : <any>null;
            this.fkey = _data["fkey"] !== undefined ? _data["fkey"] : <any>null;
            this.soLuong = _data["soLuong"] !== undefined ? _data["soLuong"] : <any>null;
            this.bienSoXe = _data["bienSoXe"] !== undefined ? _data["bienSoXe"] : <any>null;
            this.gheNgoi = _data["gheNgoi"] !== undefined ? _data["gheNgoi"] : <any>null;
            this.thoiGianXuatBen = _data["thoiGianXuatBen"] ? new Date(_data["thoiGianXuatBen"].toString()) : <any>null;
            this.tenHanhKhach = _data["tenHanhKhach"] !== undefined ? _data["tenHanhKhach"] : <any>null;
            this.soDienThoaiHK = _data["soDienThoaiHK"] !== undefined ? _data["soDienThoaiHK"] : <any>null;
            this.tenTaiXe = _data["tenTaiXe"] !== undefined ? _data["tenTaiXe"] : <any>null;
            this.emailKhachHang = _data["emailKhachHang"] !== undefined ? _data["emailKhachHang"] : <any>null;
        }
    }

    static fromJS(data: any): ThongTinVeOffline {
        data = typeof data === 'object' ? data : {};
        let result = new ThongTinVeOffline();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["veId"] = this.veId !== undefined ? this.veId : <any>null;
        data["loaiVeId"] = this.loaiVeId !== undefined ? this.loaiVeId : <any>null;
        data["fkey"] = this.fkey !== undefined ? this.fkey : <any>null;
        data["soLuong"] = this.soLuong !== undefined ? this.soLuong : <any>null;
        data["bienSoXe"] = this.bienSoXe !== undefined ? this.bienSoXe : <any>null;
        data["gheNgoi"] = this.gheNgoi !== undefined ? this.gheNgoi : <any>null;
        data["thoiGianXuatBen"] = this.thoiGianXuatBen ? this.thoiGianXuatBen.toISOString() : <any>null;
        data["tenHanhKhach"] = this.tenHanhKhach !== undefined ? this.tenHanhKhach : <any>null;
        data["soDienThoaiHK"] = this.soDienThoaiHK !== undefined ? this.soDienThoaiHK : <any>null;
        data["tenTaiXe"] = this.tenTaiXe !== undefined ? this.tenTaiXe : <any>null;
        data["emailKhachHang"] = this.emailKhachHang !== undefined ? this.emailKhachHang : <any>null;
        return data;
    }
}

export interface IThongTinVeOffline {
    veId: string;
    loaiVeId: number;
    fkey?: string | null;
    soLuong: number;
    bienSoXe?: string | null;
    gheNgoi?: string | null;
    thoiGianXuatBen?: Date | null;
    tenHanhKhach?: string | null;
    soDienThoaiHK?: string | null;
    tenTaiXe?: string | null;
    emailKhachHang?: string | null;
}

export class ThongTinVeRequest implements IThongTinVeRequest {
    bienSoXe?: string | null;
    gheNgoi?: string | null;
    thoiGianXuatBen?: Date | null;
    tenHanhKhach?: string | null;
    soDienThoaiHK?: string | null;
    tenTaiXe?: string | null;
    emailKhachHang?: string | null;
    tenVe?: string | null;
    giaTruocThue?: number | null;
    giaSauThue?: number | null;
    giaThue?: number | null;
    vat?: number | null;
    loaiVeId!: number;
    maTraCuu?: string | null;

    constructor(data?: IThongTinVeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bienSoXe = _data["bienSoXe"] !== undefined ? _data["bienSoXe"] : <any>null;
            this.gheNgoi = _data["gheNgoi"] !== undefined ? _data["gheNgoi"] : <any>null;
            this.thoiGianXuatBen = _data["thoiGianXuatBen"] ? new Date(_data["thoiGianXuatBen"].toString()) : <any>null;
            this.tenHanhKhach = _data["tenHanhKhach"] !== undefined ? _data["tenHanhKhach"] : <any>null;
            this.soDienThoaiHK = _data["soDienThoaiHK"] !== undefined ? _data["soDienThoaiHK"] : <any>null;
            this.tenTaiXe = _data["tenTaiXe"] !== undefined ? _data["tenTaiXe"] : <any>null;
            this.emailKhachHang = _data["emailKhachHang"] !== undefined ? _data["emailKhachHang"] : <any>null;
            this.tenVe = _data["tenVe"] !== undefined ? _data["tenVe"] : <any>null;
            this.giaTruocThue = _data["giaTruocThue"] !== undefined ? _data["giaTruocThue"] : <any>null;
            this.giaSauThue = _data["giaSauThue"] !== undefined ? _data["giaSauThue"] : <any>null;
            this.giaThue = _data["giaThue"] !== undefined ? _data["giaThue"] : <any>null;
            this.vat = _data["vat"] !== undefined ? _data["vat"] : <any>null;
            this.loaiVeId = _data["loaiVeId"] !== undefined ? _data["loaiVeId"] : <any>null;
            this.maTraCuu = _data["maTraCuu"] !== undefined ? _data["maTraCuu"] : <any>null;
        }
    }

    static fromJS(data: any): ThongTinVeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ThongTinVeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bienSoXe"] = this.bienSoXe !== undefined ? this.bienSoXe : <any>null;
        data["gheNgoi"] = this.gheNgoi !== undefined ? this.gheNgoi : <any>null;
        data["thoiGianXuatBen"] = this.thoiGianXuatBen ? this.thoiGianXuatBen.toISOString() : <any>null;
        data["tenHanhKhach"] = this.tenHanhKhach !== undefined ? this.tenHanhKhach : <any>null;
        data["soDienThoaiHK"] = this.soDienThoaiHK !== undefined ? this.soDienThoaiHK : <any>null;
        data["tenTaiXe"] = this.tenTaiXe !== undefined ? this.tenTaiXe : <any>null;
        data["emailKhachHang"] = this.emailKhachHang !== undefined ? this.emailKhachHang : <any>null;
        data["tenVe"] = this.tenVe !== undefined ? this.tenVe : <any>null;
        data["giaTruocThue"] = this.giaTruocThue !== undefined ? this.giaTruocThue : <any>null;
        data["giaSauThue"] = this.giaSauThue !== undefined ? this.giaSauThue : <any>null;
        data["giaThue"] = this.giaThue !== undefined ? this.giaThue : <any>null;
        data["vat"] = this.vat !== undefined ? this.vat : <any>null;
        data["loaiVeId"] = this.loaiVeId !== undefined ? this.loaiVeId : <any>null;
        data["maTraCuu"] = this.maTraCuu !== undefined ? this.maTraCuu : <any>null;
        return data;
    }
}

export interface IThongTinVeRequest {
    bienSoXe?: string | null;
    gheNgoi?: string | null;
    thoiGianXuatBen?: Date | null;
    tenHanhKhach?: string | null;
    soDienThoaiHK?: string | null;
    tenTaiXe?: string | null;
    emailKhachHang?: string | null;
    tenVe?: string | null;
    giaTruocThue?: number | null;
    giaSauThue?: number | null;
    giaThue?: number | null;
    vat?: number | null;
    loaiVeId: number;
    maTraCuu?: string | null;
}

export class AdminManagerUserDto implements IAdminManagerUserDto {
    id?: string | null;
    userName?: string | null;
    fullName?: string | null;

    constructor(data?: IAdminManagerUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.fullName = _data["fullName"] !== undefined ? _data["fullName"] : <any>null;
        }
    }

    static fromJS(data: any): AdminManagerUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminManagerUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["fullName"] = this.fullName !== undefined ? this.fullName : <any>null;
        return data;
    }
}

export interface IAdminManagerUserDto {
    id?: string | null;
    userName?: string | null;
    fullName?: string | null;
}

export class ChiTietVeLoiVm implements IChiTietVeLoiVm {
    tenant?: Tenant | null;
    chiTietHDLoiDtos?: ChiTietHDLoiDto[] | null;

    constructor(data?: IChiTietVeLoiVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenant = _data["tenant"] ? Tenant.fromJS(_data["tenant"]) : <any>null;
            if (Array.isArray(_data["chiTietHDLoiDtos"])) {
                this.chiTietHDLoiDtos = [] as any;
                for (let item of _data["chiTietHDLoiDtos"])
                    this.chiTietHDLoiDtos!.push(ChiTietHDLoiDto.fromJS(item));
            }
            else {
                this.chiTietHDLoiDtos = <any>null;
            }
        }
    }

    static fromJS(data: any): ChiTietVeLoiVm {
        data = typeof data === 'object' ? data : {};
        let result = new ChiTietVeLoiVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>null;
        if (Array.isArray(this.chiTietHDLoiDtos)) {
            data["chiTietHDLoiDtos"] = [];
            for (let item of this.chiTietHDLoiDtos)
                data["chiTietHDLoiDtos"].push(item.toJSON());
        }
        return data;
    }
}

export interface IChiTietVeLoiVm {
    tenant?: Tenant | null;
    chiTietHDLoiDtos?: ChiTietHDLoiDto[] | null;
}

export class ChiTietHDLoiDto implements IChiTietHDLoiDto {
    hoaDonVeId!: string;
    tenHoaDon?: string | null;
    maId?: string | null;
    loaiHoaDon?: string | null;
    fkey?: string | null;
    kyHieu?: string | null;
    mauSo?: string | null;
    loiXuatHD?: string | null;
    soLuong?: number | null;
    tongGiaSauThue?: number | null;
    tongGiaTruocThue?: number | null;
    tongTienVat?: number | null;
    vat!: number;
    tenNguoiMuaHang?: string | null;
    tenantId!: number;

    constructor(data?: IChiTietHDLoiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hoaDonVeId = _data["hoaDonVeId"] !== undefined ? _data["hoaDonVeId"] : <any>null;
            this.tenHoaDon = _data["tenHoaDon"] !== undefined ? _data["tenHoaDon"] : <any>null;
            this.maId = _data["maId"] !== undefined ? _data["maId"] : <any>null;
            this.loaiHoaDon = _data["loaiHoaDon"] !== undefined ? _data["loaiHoaDon"] : <any>null;
            this.fkey = _data["fkey"] !== undefined ? _data["fkey"] : <any>null;
            this.kyHieu = _data["kyHieu"] !== undefined ? _data["kyHieu"] : <any>null;
            this.mauSo = _data["mauSo"] !== undefined ? _data["mauSo"] : <any>null;
            this.loiXuatHD = _data["loiXuatHD"] !== undefined ? _data["loiXuatHD"] : <any>null;
            this.soLuong = _data["soLuong"] !== undefined ? _data["soLuong"] : <any>null;
            this.tongGiaSauThue = _data["tongGiaSauThue"] !== undefined ? _data["tongGiaSauThue"] : <any>null;
            this.tongGiaTruocThue = _data["tongGiaTruocThue"] !== undefined ? _data["tongGiaTruocThue"] : <any>null;
            this.tongTienVat = _data["tongTienVat"] !== undefined ? _data["tongTienVat"] : <any>null;
            this.vat = _data["vat"] !== undefined ? _data["vat"] : <any>null;
            this.tenNguoiMuaHang = _data["tenNguoiMuaHang"] !== undefined ? _data["tenNguoiMuaHang"] : <any>null;
            this.tenantId = _data["tenantId"] !== undefined ? _data["tenantId"] : <any>null;
        }
    }

    static fromJS(data: any): ChiTietHDLoiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChiTietHDLoiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hoaDonVeId"] = this.hoaDonVeId !== undefined ? this.hoaDonVeId : <any>null;
        data["tenHoaDon"] = this.tenHoaDon !== undefined ? this.tenHoaDon : <any>null;
        data["maId"] = this.maId !== undefined ? this.maId : <any>null;
        data["loaiHoaDon"] = this.loaiHoaDon !== undefined ? this.loaiHoaDon : <any>null;
        data["fkey"] = this.fkey !== undefined ? this.fkey : <any>null;
        data["kyHieu"] = this.kyHieu !== undefined ? this.kyHieu : <any>null;
        data["mauSo"] = this.mauSo !== undefined ? this.mauSo : <any>null;
        data["loiXuatHD"] = this.loiXuatHD !== undefined ? this.loiXuatHD : <any>null;
        data["soLuong"] = this.soLuong !== undefined ? this.soLuong : <any>null;
        data["tongGiaSauThue"] = this.tongGiaSauThue !== undefined ? this.tongGiaSauThue : <any>null;
        data["tongGiaTruocThue"] = this.tongGiaTruocThue !== undefined ? this.tongGiaTruocThue : <any>null;
        data["tongTienVat"] = this.tongTienVat !== undefined ? this.tongTienVat : <any>null;
        data["vat"] = this.vat !== undefined ? this.vat : <any>null;
        data["tenNguoiMuaHang"] = this.tenNguoiMuaHang !== undefined ? this.tenNguoiMuaHang : <any>null;
        data["tenantId"] = this.tenantId !== undefined ? this.tenantId : <any>null;
        return data;
    }
}

export interface IChiTietHDLoiDto {
    hoaDonVeId: string;
    tenHoaDon?: string | null;
    maId?: string | null;
    loaiHoaDon?: string | null;
    fkey?: string | null;
    kyHieu?: string | null;
    mauSo?: string | null;
    loiXuatHD?: string | null;
    soLuong?: number | null;
    tongGiaSauThue?: number | null;
    tongGiaTruocThue?: number | null;
    tongTienVat?: number | null;
    vat: number;
    tenNguoiMuaHang?: string | null;
    tenantId: number;
}

export class DtResultOfBaoCaoSanLuongVeVm implements IDtResultOfBaoCaoSanLuongVeVm {
    draw!: number;
    recordsTotal!: number;
    recordsFiltered!: number;
    data?: BaoCaoSanLuongVeVm[] | null;
    error?: string | null;
    partialView?: string | null;

    constructor(data?: IDtResultOfBaoCaoSanLuongVeVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.draw = _data["draw"] !== undefined ? _data["draw"] : <any>null;
            this.recordsTotal = _data["recordsTotal"] !== undefined ? _data["recordsTotal"] : <any>null;
            this.recordsFiltered = _data["recordsFiltered"] !== undefined ? _data["recordsFiltered"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(BaoCaoSanLuongVeVm.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.error = _data["error"] !== undefined ? _data["error"] : <any>null;
            this.partialView = _data["partialView"] !== undefined ? _data["partialView"] : <any>null;
        }
    }

    static fromJS(data: any): DtResultOfBaoCaoSanLuongVeVm {
        data = typeof data === 'object' ? data : {};
        let result = new DtResultOfBaoCaoSanLuongVeVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["draw"] = this.draw !== undefined ? this.draw : <any>null;
        data["recordsTotal"] = this.recordsTotal !== undefined ? this.recordsTotal : <any>null;
        data["recordsFiltered"] = this.recordsFiltered !== undefined ? this.recordsFiltered : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["error"] = this.error !== undefined ? this.error : <any>null;
        data["partialView"] = this.partialView !== undefined ? this.partialView : <any>null;
        return data;
    }
}

export interface IDtResultOfBaoCaoSanLuongVeVm {
    draw: number;
    recordsTotal: number;
    recordsFiltered: number;
    data?: BaoCaoSanLuongVeVm[] | null;
    error?: string | null;
    partialView?: string | null;
}

export class BaoCaoSanLuongVeVm implements IBaoCaoSanLuongVeVm {
    tenantId!: number;
    tenDonVi?: string | null;
    tenantGroupName?: string | null;
    sanLuong!: number;
    isRelease?: boolean | null;
    thoiGianChayChinhThuc?: Date | null;
    thoiGianKhoiTaoHT?: Date | null;

    constructor(data?: IBaoCaoSanLuongVeVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"] !== undefined ? _data["tenantId"] : <any>null;
            this.tenDonVi = _data["tenDonVi"] !== undefined ? _data["tenDonVi"] : <any>null;
            this.tenantGroupName = _data["tenantGroupName"] !== undefined ? _data["tenantGroupName"] : <any>null;
            this.sanLuong = _data["sanLuong"] !== undefined ? _data["sanLuong"] : <any>null;
            this.isRelease = _data["isRelease"] !== undefined ? _data["isRelease"] : <any>null;
            this.thoiGianChayChinhThuc = _data["thoiGianChayChinhThuc"] ? new Date(_data["thoiGianChayChinhThuc"].toString()) : <any>null;
            this.thoiGianKhoiTaoHT = _data["thoiGianKhoiTaoHT"] ? new Date(_data["thoiGianKhoiTaoHT"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): BaoCaoSanLuongVeVm {
        data = typeof data === 'object' ? data : {};
        let result = new BaoCaoSanLuongVeVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId !== undefined ? this.tenantId : <any>null;
        data["tenDonVi"] = this.tenDonVi !== undefined ? this.tenDonVi : <any>null;
        data["tenantGroupName"] = this.tenantGroupName !== undefined ? this.tenantGroupName : <any>null;
        data["sanLuong"] = this.sanLuong !== undefined ? this.sanLuong : <any>null;
        data["isRelease"] = this.isRelease !== undefined ? this.isRelease : <any>null;
        data["thoiGianChayChinhThuc"] = this.thoiGianChayChinhThuc ? this.thoiGianChayChinhThuc.toISOString() : <any>null;
        data["thoiGianKhoiTaoHT"] = this.thoiGianKhoiTaoHT ? this.thoiGianKhoiTaoHT.toISOString() : <any>null;
        return data;
    }
}

export interface IBaoCaoSanLuongVeVm {
    tenantId: number;
    tenDonVi?: string | null;
    tenantGroupName?: string | null;
    sanLuong: number;
    isRelease?: boolean | null;
    thoiGianChayChinhThuc?: Date | null;
    thoiGianKhoiTaoHT?: Date | null;
}

export class BaoCaoRequest implements IBaoCaoRequest {
    tuNgay?: string | null;
    denNgay?: string | null;
    isReleased?: boolean | null;
    tenantGroupId?: number | null;
    pageIndex?: number | null;
    pageSize?: number | null;

    constructor(data?: IBaoCaoRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tuNgay = _data["tuNgay"] !== undefined ? _data["tuNgay"] : <any>null;
            this.denNgay = _data["denNgay"] !== undefined ? _data["denNgay"] : <any>null;
            this.isReleased = _data["isReleased"] !== undefined ? _data["isReleased"] : <any>null;
            this.tenantGroupId = _data["tenantGroupId"] !== undefined ? _data["tenantGroupId"] : <any>null;
            this.pageIndex = _data["pageIndex"] !== undefined ? _data["pageIndex"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
        }
    }

    static fromJS(data: any): BaoCaoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BaoCaoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tuNgay"] = this.tuNgay !== undefined ? this.tuNgay : <any>null;
        data["denNgay"] = this.denNgay !== undefined ? this.denNgay : <any>null;
        data["isReleased"] = this.isReleased !== undefined ? this.isReleased : <any>null;
        data["tenantGroupId"] = this.tenantGroupId !== undefined ? this.tenantGroupId : <any>null;
        data["pageIndex"] = this.pageIndex !== undefined ? this.pageIndex : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        return data;
    }
}

export interface IBaoCaoRequest {
    tuNgay?: string | null;
    denNgay?: string | null;
    isReleased?: boolean | null;
    tenantGroupId?: number | null;
    pageIndex?: number | null;
    pageSize?: number | null;
}

export class DtResultOfTenant implements IDtResultOfTenant {
    draw!: number;
    recordsTotal!: number;
    recordsFiltered!: number;
    data?: Tenant[] | null;
    error?: string | null;
    partialView?: string | null;

    constructor(data?: IDtResultOfTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.draw = _data["draw"] !== undefined ? _data["draw"] : <any>null;
            this.recordsTotal = _data["recordsTotal"] !== undefined ? _data["recordsTotal"] : <any>null;
            this.recordsFiltered = _data["recordsFiltered"] !== undefined ? _data["recordsFiltered"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Tenant.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.error = _data["error"] !== undefined ? _data["error"] : <any>null;
            this.partialView = _data["partialView"] !== undefined ? _data["partialView"] : <any>null;
        }
    }

    static fromJS(data: any): DtResultOfTenant {
        data = typeof data === 'object' ? data : {};
        let result = new DtResultOfTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["draw"] = this.draw !== undefined ? this.draw : <any>null;
        data["recordsTotal"] = this.recordsTotal !== undefined ? this.recordsTotal : <any>null;
        data["recordsFiltered"] = this.recordsFiltered !== undefined ? this.recordsFiltered : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["error"] = this.error !== undefined ? this.error : <any>null;
        data["partialView"] = this.partialView !== undefined ? this.partialView : <any>null;
        return data;
    }
}

export interface IDtResultOfTenant {
    draw: number;
    recordsTotal: number;
    recordsFiltered: number;
    data?: Tenant[] | null;
    error?: string | null;
    partialView?: string | null;
}

export class AdminTenantGroupDto implements IAdminTenantGroupDto {
    tenantId!: number;
    tenantName?: string | null;
    isSelected!: boolean;

    constructor(data?: IAdminTenantGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"] !== undefined ? _data["tenantId"] : <any>null;
            this.tenantName = _data["tenantName"] !== undefined ? _data["tenantName"] : <any>null;
            this.isSelected = _data["isSelected"] !== undefined ? _data["isSelected"] : <any>null;
        }
    }

    static fromJS(data: any): AdminTenantGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminTenantGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId !== undefined ? this.tenantId : <any>null;
        data["tenantName"] = this.tenantName !== undefined ? this.tenantName : <any>null;
        data["isSelected"] = this.isSelected !== undefined ? this.isSelected : <any>null;
        return data;
    }
}

export interface IAdminTenantGroupDto {
    tenantId: number;
    tenantName?: string | null;
    isSelected: boolean;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}